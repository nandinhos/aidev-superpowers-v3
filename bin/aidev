#!/bin/bash

# ============================================================================
# AI Dev Superpowers V3 - CLI Principal
# ============================================================================
# Comando unificado 'aidev' para gest√£o de projetos com AI
# 
# Uso: aidev <comando> [op√ß√µes]
# ============================================================================

set -eEo pipefail

# Handler de erro para Auto-Cura (Fase 4)
error_handler() {
    local exit_code=$?
    local line_no=$1
    
    # Ignora erros se j√° estivermos dentro do doctor para evitar loop infinito
    if [[ "${BASH_COMMAND:-}" == *"doctor"* ]]; then
        return
    fi

    echo ""
    echo "‚ùå $(_ "error_ops") (Erro: $exit_code na linha $line_no)"
    echo "üîç $(_ "suggest_doctor")"
    
    # Monitoramento de triggers ap√≥s erro
    if type triggers__watch_errors &>/dev/null; then
        triggers__watch_errors "${BASH_COMMAND:-}"
    fi
    
    # Sprint 6.2: Advanced Error Recovery
    # Analisa erro e sugere corre√ß√µes autom√°ticas
    if type error_recovery_handler &>/dev/null; then
        local last_error=$(tail -n 5 /tmp/aidev_last_error 2>/dev/null || echo "Erro n√£o capturado")
        # error_recovery_handler exibe sugest√µes via stderr (visivel no terminal)
        # e retorna JSON de an√°lise via stdout (salvo no arquivo)
        error_recovery_handler "$exit_code" "$line_no" "${BASH_COMMAND:-}" "$last_error" > /tmp/aidev_error_analysis.json
    fi
    
    echo ""
}

trap 'error_handler $LINENO' ERR

# Detecta diret√≥rio do script (resolve symlinks)
SOURCE="${BASH_SOURCE[0]}"
while [ -L "$SOURCE" ]; do
    DIR="$(cd -P "$(dirname "$SOURCE")" && pwd)"
    SOURCE="$(readlink "$SOURCE")"
    [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
done
AIDEV_BIN_DIR="$(cd -P "$(dirname "$SOURCE")" && pwd)"
AIDEV_ROOT_DIR="$(dirname "$AIDEV_BIN_DIR")"
AIDEV_LIB_DIR="$AIDEV_ROOT_DIR/lib"

# Carrega m√≥dulos essenciais
source "$AIDEV_LIB_DIR/loader.sh"
load_essential_modules
load_module "templates"
load_module "mcp"
load_module "lessons"
load_module "kb"
load_module "triggers"
load_module "error-recovery" 2>/dev/null || true

# Carrega m√≥dulo de verifica√ß√£o de vers√£o (silencioso)
load_module "version-check" 2>/dev/null || true

# Verifica atualiza√ß√µes e pergunta ao usu√°rio (s√≠ncrono)
if type version_check_prompt &>/dev/null; then
    version_check_prompt
fi

# Tenta carregar ambiente (idioma, segredos)
load_env 2>/dev/null || true

# ============================================================================
# Subcomandos
# ============================================================================

# Subcomando: init
# Inicializa AI Dev em um projeto
cmd_init() {
    parse_args "$@"
    
    if ! validate_args; then
        exit 1
    fi
    # Diret√≥rio de instala√ß√£o
    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")

    # Sele√ß√£o de Idioma Interativa
    if [ "${AIDEV_INTERACTIVE:-true}" = "true" ] && [ "${CLI_LANGUAGE_SET:-false}" = "false" ]; then
        echo -n "$(_ "select_lang")"
        read -r selected_lang
        case "$selected_lang" in
            en|EN) CLI_LANGUAGE="en" ;;
            pt|PT|pt-BR|PT-BR) CLI_LANGUAGE="pt-BR" ;;
            *) CLI_LANGUAGE="pt-BR" ;; # Default
        esac
    fi
    set_language "${CLI_LANGUAGE:-pt-BR}"

    print_header "AI Dev Superpowers"
    print_mode "$CLI_MODE" "$(_ "init_header") $install_path"
    
    # Auto-detec√ß√£o de stack
    if [ "$CLI_AUTO_DETECT" = "true" ]; then
        CLI_STACK=$(detect_stack "$install_path")
        print_info "Stack detectada: $CLI_STACK"
    fi
    
    # Auto-detec√ß√£o de plataforma
    if [ "$CLI_PLATFORM" = "auto" ]; then
        CLI_PLATFORM=$(detect_platform)
        print_info "Plataforma detectada: $CLI_PLATFORM"
    fi

    # Auto-detec√ß√£o de Maturidade e Estilo (Smart Context)
    local maturity=$(detect_maturity "$install_path")
    local style=$(detect_style "$install_path")
    print_info "Contexto: $maturity | Estilo: ${style:-none}"

    # Valida√ß√£o de Greenfield (PRD)
    export CONTEXT_INSTRUCTIONS=""

    if [ "$maturity" = "greenfield" ]; then
        if [ ! -f "$install_path/docs/PRD.md" ] && [ ! -f "$install_path/PRD.md" ]; then
             print_warning "Greenfield detectado: PRD ausente!"
             echo "   ‚Ñπ  Recomendado criar 'docs/PRD.md' para que o Agente Architect possa"
             echo "      analisar requisitos e criar skills personalizadas."
        fi
        CONTEXT_INSTRUCTIONS=$(cat <<EOF
## Modo: Greenfield (Novo Projeto)
- **Foco Prim√°rio**: Setup e Arquitetura.
- **Regra de Ouro**: Siga o PRD (\`docs/PRD.md\`) como a unica fonte da verdade.
- **Workflow**: 
    1. Architect deve criar skills personalizadas baseadas no PRD.
    2. Validar se o ERD (Diagrama de Entidade-Relacionamento) existe.
    3. Definir padr√µes de c√≥digo para o projeto desde o dia 1.
EOF
)
    elif [ "$maturity" = "brownfield" ]; then
         print_info "Brownfield detectado: Sugerimos rodar 'legacy-analyzer' para diagn√≥stico."
         CONTEXT_INSTRUCTIONS=$(cat <<EOF
## Modo: Brownfield (Projeto Legado e Em Andamento)
- **Foco Prim√°rio**: Estabilidade e Manutenibilidade.
- **Regra de Ouro**: "First, do no harm". Analise antes de alterar.
- **Workflow**:
    1. Antes de iniciar feature nova, execute \`legacy-analyzer\` para mapa de impacto.
    2. Respeite os padr√µes de estilo encontrados (verifique \`.eslintrc\`, \`pint.json\`, etc).
    3. Use a skill \`learned-lesson\` frequentemente para documentar armadilhas do legado.
EOF
)
    fi
    export CONTEXT_INSTRUCTIONS
    
    # Mostra configura√ß√£o
    if [ "${AIDEV_DEBUG:-false}" = "true" ]; then
        show_config_summary
    fi
    
    # Dry run apenas mostra o que seria feito
    if [ "$AIDEV_DRY_RUN" = "true" ]; then
        print_info "[DRY-RUN] Simulando instala√ß√£o..."
    fi
    
    # Reseta contadores
    reset_counters
    
    # Cria estrutura base
    print_step "$(_ "step_structure")"
    create_base_structure "$install_path"
    
    # Instala agentes
    print_step "$(_ "step_agents")"
    install_agents "$install_path"
    
    # Instala skills
    print_step "$(_ "step_skills")"
    install_skills "$install_path"
    
    # Instala rules
    print_step "$(_ "step_rules")"
    install_rules "$install_path" "$CLI_STACK"

    # Instala LLM limits (guardrails)
    install_llm_limits "$install_path" 2>/dev/null || true

    # Configura segredos PRIMEIRO (antes do MCP para ter API Keys dispon√≠veis)
    if [ "$CLI_NO_MCP" != "true" ]; then
        print_step "$(_ "step_secrets")"
        setup_secrets "$install_path"

        # Carrega as vari√°veis do .env para usar na configura√ß√£o MCP
        load_env "$install_path/.env"
    fi

    # Configura MCP (agora com API Keys j√° definidas)
    if [ "$CLI_NO_MCP" != "true" ]; then
        print_step "$(_ "step_mcp")"
        configure_mcp "$install_path" "$CLI_PLATFORM"
    fi

    # Instala instru√ß√µes de ativa√ß√£o para a plataforma
    print_step "$(_ "step_platform")"
    install_platform_instructions "$install_path" "$CLI_PLATFORM"

    # Instala Memory Sync e Triggers
    print_step "Configurando Memory Sync..."
    install_memory_sync "$install_path"
    install_triggers "$install_path"
    
    # Instala Planos e Roadmap (v3.7)
    print_step "Provisionando Metodologia SGAITI..."
    install_plans "$install_path"

    # Configura gitignore
    print_step "$(_ "step_gitignore")"
    setup_gitignore "$install_path"

    # Persiste estado inicial
    export CLI_INSTALL_PATH="$install_path"
    set_state_value "current_fase" "3"
    set_state_value "current_sprint" "4"
    set_state_value "current_platform" "$CLI_PLATFORM"
    set_state_value "current_stack" "$CLI_STACK"
    set_state_value "language" "$CLI_LANGUAGE"
    set_state_value "maturity" "$maturity"
    set_state_value "style" "$style"
    set_state_value "initialized_at" "$(date -Iseconds)"

    # Grava versao do projeto (MANIFEST.local.json)
    load_module "migration" 2>/dev/null || true
    if type migration_stamp &>/dev/null; then
        migration_stamp "$install_path" 2>/dev/null || true
    fi

    # Sum√°rio final
    print_summary "$CLI_MODE" "$CLI_STACK"

    print_success "$(_ "init_success")"
}

# Subcomando: upgrade
# Atualiza instala√ß√£o existente
cmd_upgrade() {
    parse_args "$@"

    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")

    if ! has_aidev_installed "$install_path"; then
        print_error "AI Dev n√£o est√° instalado neste diret√≥rio"
        print_info "Use 'aidev init' para instalar"
        exit 1
    fi

    print_header "AI Dev Superpowers"
    print_mode "upgrade" "Atualizando em $install_path"

    # Detecta stack e plataforma
    CLI_STACK=$(detect_stack "$install_path")
    local platform="${CLI_PLATFORM:-auto}"
    if [ "$platform" = "auto" ]; then
        platform=$(detect_platform)
    fi
    print_info "Stack: $CLI_STACK | Plataforma: $platform"

    # Carregar manifesto e upgrade se disponiveis
    load_module "manifest" 2>/dev/null || true
    load_module "upgrade" 2>/dev/null || true
    if type manifest_load &>/dev/null; then
        manifest_load 2>/dev/null || true
    fi

    # Dry-run: apenas mostra preview
    if [ "$AIDEV_DRY_RUN" = "true" ] && type upgrade_dry_run &>/dev/null; then
        upgrade_dry_run "$install_path"
        return 0
    fi

    # Backup antes de atualizar (expandido: agents, skills, rules, mcp)
    print_step "Criando backup..."
    local backup_dir=""
    if type upgrade_backup_full &>/dev/null; then
        backup_dir=$(upgrade_backup_full "$install_path")
    else
        backup_dir="$install_path/.aidev/backups/$(date +%Y%m%d%H%M%S)"
        ensure_dir "$backup_dir"
        cp -r "$install_path/.aidev/agents" "$backup_dir/" 2>/dev/null || true
        cp -r "$install_path/.aidev/skills" "$backup_dir/" 2>/dev/null || true
    fi

    reset_counters
    # NOTA: AIDEV_FORCE n√£o est√° mais ativo por padr√£o
    # Usu√°rios devem usar 'aidev upgrade --force' para sobrescrever customiza√ß√µes
    # Isso protege arquivos modificados em .aidev/agents/ e .aidev/skills/

    # Garante estrutura base (novos diret√≥rios)
    create_base_structure "$install_path"

    # Reinstala componentes
    print_step "Atualizando agentes..."
    install_agents "$install_path"

    print_step "Atualizando skills..."
    install_skills "$install_path"

    print_step "Atualizando rules..."
    install_rules "$install_path" "$CLI_STACK"

    # Instala LLM limits (guardrails)
    install_llm_limits "$install_path" 2>/dev/null || true

    # Informa sobre prote√ß√£o de customiza√ß√µes
    if [ "$AIDEV_FORCE" != "true" ]; then
        echo ""
        echo "üõ°Ô∏è  Arquivos customizados em .aidev/agents/ e .aidev/skills/ foram preservados."
        echo "   Use 'aidev upgrade --force' se quiser sobrescrever todas as customiza√ß√µes."
        echo "   Backup salvo em: $backup_dir"
        echo ""
    fi

    # Atualiza instru√ß√µes de plataforma
    print_step "Atualizando instru√ß√µes de plataforma..."
    install_platform_instructions "$install_path" "$platform"

    # Atualiza Memory Sync e Triggers
    print_step "Atualizando Memory Sync..."
    install_memory_sync "$install_path"
    install_triggers "$install_path"

    # Atualiza estrutura de planos para v4.3.0
    print_step "Atualizando estrutura de planos..."
    upgrade_plans_structure "$install_path"

    # Atualiza MCP (v3.8)
    print_step "Atualizando configura√ß√µes MCP..."
    configure_mcp "$install_path" "$platform"

    # Registrar checksums pos-upgrade
    if type upgrade_record_checksums &>/dev/null; then
        print_step "Registrando checksums..."
        upgrade_record_checksums "$install_path"
    fi

    # Executa migracoes se necessario
    load_module "migration" 2>/dev/null || true
    if type migration_needed &>/dev/null; then
        if migration_needed "$install_path" 2>/dev/null; then
            local proj_version
            proj_version=$(migration_get_project_version "$install_path")
            print_step "Executando migracoes ($proj_version -> $AIDEV_VERSION)..."
            migration_execute "$install_path" "$proj_version" "$AIDEV_VERSION" 2>/dev/null || true
        fi
        migration_stamp "$install_path" 2>/dev/null || true
    fi

    print_summary "upgrade" "$CLI_STACK"
    print_success "Atualiza√ß√£o conclu√≠da!"
    print_info "Backup salvo em: $backup_dir"
}

# Subcomando: add-skill
# Adiciona skill customizada
cmd_add_skill() {
    local skill_name="${1:-}"
    shift || true
    parse_args "$@"
    
    if [ -z "$skill_name" ]; then
        print_error "Nome da skill √© obrigat√≥rio"
        echo "Uso: aidev add-skill <nome>"
        exit 1
    fi
    
    local install_path="${CLI_INSTALL_PATH:-.}"
    local skill_dir="$install_path/.aidev/skills/$skill_name"
    
    if [ -d "$skill_dir" ] && [ "$AIDEV_FORCE" != "true" ]; then
        print_warning "Skill '$skill_name' j√° existe (use --force)"
        exit 1
    fi
    
    print_step "Criando skill '$skill_name'..."
    
    ensure_dir "$skill_dir"
    
    # Cria SKILL.md template
    cat > "$skill_dir/SKILL.md" << EOF
---
name: $skill_name
description: Descri√ß√£o da skill $skill_name
triggers:
  - "trigger1"
  - "trigger2"
globs:
  - "**/*.md"
---

# $skill_name Skill

## When to Use
[Descreva quando usar esta skill]

## Purpose
[Descreva o prop√≥sito]

## Process
1. [Passo 1]
2. [Passo 2]
3. [Passo 3]

## Key Principles
- [Princ√≠pio 1]
- [Princ√≠pio 2]
EOF
    
    print_success "Skill '$skill_name' criada em $skill_dir"
    print_info "Edite o arquivo SKILL.md para customizar"
}

# Subcomando: add-rule
# Adiciona regra customizada
cmd_add_rule() {
    local rule_name="${1:-}"
    shift || true
    parse_args "$@"
    
    if [ -z "$rule_name" ]; then
        print_error "Nome da rule √© obrigat√≥rio"
        echo "Uso: aidev add-rule <nome>"
        exit 1
    fi
    
    local install_path="${CLI_INSTALL_PATH:-.}"
    local rule_file="$install_path/.aidev/rules/${rule_name}.md"
    
    if [ -f "$rule_file" ] && [ "$AIDEV_FORCE" != "true" ]; then
        print_warning "Rule '$rule_name' j√° existe (use --force)"
        exit 1
    fi
    
    print_step "Criando rule '$rule_name'..."
    
    ensure_dir "$(dirname "$rule_file")"
    
    cat > "$rule_file" << EOF
# $rule_name Rules

## Conventions
[Descreva as conven√ß√µes]

## Patterns
[Descreva os patterns a seguir]

## Anti-Patterns
[Descreva o que evitar]

## Examples
\`\`\`
// Exemplo de c√≥digo
\`\`\`
EOF
    
    print_success "Rule '$rule_name' criada: $rule_file"
}

# Subcomando: add-agent
# Adiciona agente customizado
cmd_add_agent() {
    local agent_name="${1:-}"
    shift || true
    parse_args "$@"
    
    if [ -z "$agent_name" ]; then
        print_error "Nome do agente √© obrigat√≥rio"
        echo "Uso: aidev add-agent <nome>"
        exit 1
    fi
    
    local install_path="${CLI_INSTALL_PATH:-.}"
    local agent_file="$install_path/.aidev/agents/${agent_name}.md"
    
    if [ -f "$agent_file" ] && [ "$AIDEV_FORCE" != "true" ]; then
        print_warning "Agent '$agent_name' j√° existe (use --force)"
        exit 1
    fi
    
    print_step "Criando agent '$agent_name'..."
    
    ensure_dir "$(dirname "$agent_file")"
    
    cat > "$agent_file" << EOF
# $agent_name Agent

## Role
[Descreva o papel deste agente]

## Responsibilities
- [Responsabilidade 1]
- [Responsabilidade 2]
- [Responsabilidade 3]

## Guidelines
- [Guideline 1]
- [Guideline 2]

## Tools
- [Tool 1]
- [Tool 2]
EOF
    
    print_success "Agent '$agent_name' criado: $agent_file"
}

# Subcomando: status
# Mostra status da instala√ß√£o
cmd_status() {
    parse_args "$@"
    
    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")
    
    print_header "AI Dev Superpowers"
    
    if ! has_aidev_installed "$install_path"; then
        print_warning "AI Dev n√£o est√° instalado neste diret√≥rio"
        exit 0
    fi
    
    print_success "AI Dev instalado: $install_path/.aidev/"
    
    # Detecta contexto
    local stack=$(detect_stack "$install_path")
    local platform=$(detect_platform)
    local project_name=$(detect_project_name "$install_path")
    local runtime=$(detect_runtime)
    
    print_section "Contexto"
    echo "  Projeto:    $project_name"
    echo "  Stack:      $stack"
    echo "  Plataforma: $platform"
    echo "  Runtime:    $runtime"
    
    # Progresso da Sess√£o (L√™ do estado unificado)
    local unified_state_file="$install_path/.aidev/state/unified.json"
    local active_intent=""
    local intent_desc=""
    local active_skill=""
    local last_checkpoint=""
    local current_fase=""
    local current_sprint=""

    if [ -f "$unified_state_file" ] && command -v jq >/dev/null 2>&1; then
        active_intent=$(jq -r '.active_intent // empty' "$unified_state_file")
        intent_desc=$(jq -r '.intent_description // empty' "$unified_state_file")
        active_skill=$(jq -r '.active_skill // empty' "$unified_state_file")
        last_checkpoint=$(jq -r '.rollback_stack[-1].description // empty' "$unified_state_file")
        current_fase=$(jq -r '.current_fase // empty' "$unified_state_file")
        current_sprint=$(jq -r '.current_sprint // empty' "$unified_state_file")
    fi

    # Exibe progresso apenas se ha dados ativos
    if [ -n "$active_intent" ] || [ -n "$active_skill" ]; then
        print_section "Progresso (Em Tempo Real)"
        [ -n "$active_intent" ] && echo "  Intent:     $active_intent"
        [ -n "$intent_desc" ] && echo "  Descri√ß√£o:  $intent_desc"
        [ -n "$active_skill" ] && echo "  Skill:      $active_skill"
        [ -n "$last_checkpoint" ] && echo "  Checkpoint: $last_checkpoint"
        if [ -n "$current_fase" ] || [ -n "$current_sprint" ]; then
            echo "  Fase/Sprint: ${current_fase:-0} / ${current_sprint:-0}"
        fi
    fi
    
    # Hist√≥rico Git Recente
    if [ -d "$install_path/.git" ]; then
        print_section "Hist√≥rico Recente (Git)"
        git -C "$install_path" log -n 3 --oneline | sed 's/^/  /'
    fi
    
    # Lista agentes
    print_section "Agentes Instalados"
    local agents_dir="$install_path/.aidev/agents"
    if [ -d "$agents_dir" ]; then
        local count=0
        for agent in "$agents_dir"/*.md; do
            if [ -f "$agent" ]; then
                echo "  ‚Ä¢ $(basename "$agent" .md)"
                ((count++)) || true
            fi
        done
        echo "  Total: $count agentes"
    else
        echo "  Nenhum agente instalado"
    fi
    
    # Lista skills
    print_section "Skills Instaladas"
    local skills_dir="$install_path/.aidev/skills"
    if [ -d "$skills_dir" ]; then
        local count=0
        for skill in "$skills_dir"/*/SKILL.md; do
            if [ -f "$skill" ]; then
                local skill_name=$(dirname "$skill")
                echo "  ‚Ä¢ $(basename "$skill_name")"
                ((count++)) || true
            fi
        done
        echo "  Total: $count skills"
    else
        echo "  Nenhuma skill instalada"
    fi
    
    # Lista rules
    print_section "Rules Instaladas"
    local rules_dir="$install_path/.aidev/rules"
    if [ -d "$rules_dir" ]; then
        local count=0
        for rule in "$rules_dir"/*.md; do
            if [ -f "$rule" ]; then
                echo "  ‚Ä¢ $(basename "$rule" .md)"
                ((count++)) || true
            fi
        done
        echo "  Total: $count rules"
    else
        echo "  Nenhuma rule instalada"
    fi
    
    echo ""
}

# Subcomando: snapshot
# Gera um resumo do contexto atual para migra√ß√£o entre IAs
cmd_snapshot() {
    local feature_filter=""
    local optimize=false
    local include_paths=()

    # Parsing local de flags avan√ßadas
    local args=()
    while [[ $# -gt 0 ]]; do
        case $1 in
            --feature)
                feature_filter="$2"
                shift 2
                ;;
            --optimize)
                optimize=true
                shift
                ;;
            --include)
                include_paths+=("$2")
                shift 2
                ;;
            *)
                args+=("$1")
                shift
                ;;
        esac
    done
    
    # Chama parse_args original com os argumentos restantes
    parse_args "${args[@]}"
    
    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")
    
    if ! has_aidev_installed "$install_path"; then
        print_error "AI Dev n√£o est√° instalado neste diret√≥rio"
        exit 1
    fi

    print_header "AI Dev Advanced Snapshot"
    [[ "$optimize" = "true" ]] && print_info "Otimiza√ß√£o de tokens ativa (Logs/Temp removidos)"
    [[ -n "$feature_filter" ]] && print_info "Filtro de Feature: $feature_filter"
    echo ""

    # Coleta dados
    local fase=$(get_state_value "current_fase" "1")
    local sprint=$(get_state_value "current_sprint" "0")
    local task=$(get_state_value "current_task" "Pendente")
    local project_name=$(detect_project_name "$install_path")
    local stack=$(detect_stack "$install_path")
    local platform=$(detect_platform)

    # In√≠cio do bloco de snapshot
    echo "--- SNAPSHOT START ---"
    echo "Crie um novo chat de IA e cole o conte√∫do abaixo:"
    echo "------------------------------------------------"
    echo ""
    echo "# üõ∞Ô∏è AI DEV CONTEXT SNAPSHOT: $project_name"
    echo ""
    echo "## üìç Estado Operacional"
    echo "- **Fase**: $fase"
    echo "- **Sprint**: $sprint"
    echo "- **Tarefa Atual**: $task"
    echo "- **Stack**: $stack"
    echo "- **Origem**: $platform"
    echo ""

    echo "## üìú Hist√≥rico Recente (Git)"
    if [ -d "$install_path/.git" ]; then
        git log -n 5 --oneline | sed 's/^/- /'
    else
        echo "- (Git n√£o dispon√≠vel ou n√£o inicializado)"
    fi
    echo ""

    echo "## üìã Decis√µes e Planos Ativos"
    local plans=""
    if [ -n "$feature_filter" ]; then
        local feat_file="$install_path/.aidev/plans/features/$feature_filter.md"
        if [ -f "$feat_file" ]; then
            plans="- .aidev/plans/features/$feature_filter.md (Feature Foco)\n"
        fi
    fi
    [ -f "$install_path/implementation_plan.md" ] && plans="$plans- ./implementation_plan.md\n"
    [ -d "$install_path/docs/plans" ] && plans="$plans$(ls "$install_path/docs/plans"/*.md 2>/dev/null | sed "s|$install_path/||" | sed 's/^/- /')\n"
    
    if [ -n "$plans" ]; then
        echo -e "$plans"
    else
        echo "- Nenhum plano de implementa√ß√£o detectado."
    fi
    echo ""

    echo "## üß† Base de Conhecimento (KB)"
    local kb_dir="$install_path/.aidev/memory/kb"
    if [ -d "$kb_dir" ]; then
        shopt -s nullglob
        local kb_files=("$kb_dir"/*.md)
        shopt -u nullglob
        local kb_count=${#kb_files[@]}
        
        if [ "$kb_count" -gt 0 ]; then
            echo "- $kb_count li√ß√µes dispon√≠veis em .aidev/memory/kb/"
            # Lista as 3 mais recentes
            ls -t "$kb_dir"/*.md 2>/dev/null | head -n 3 | sed 's/^/- /'
        else
            echo "- Nenhuma li√ß√£o registrada."
        fi
    else
        echo "- Nenhuma li√ß√£o registrada."
    fi
    echo ""

    # Arquivos Adicionais (--include)
    if [ ${#include_paths[@]} -gt 0 ]; then
        echo "## üìÇ Arquivos de Contexto Adicionais"
        for p in "${include_paths[@]}"; do
            if [ -f "$p" ]; then
                echo "### Conte√∫do de $p"
                echo "\`\`\`"
                cat "$p"
                echo "\`\`\`"
                echo ""
            fi
        done
    fi

    # Estado Unificado
    local unified_state_file="$install_path/.aidev/state/unified.json"
    if [ -f "$unified_state_file" ]; then
        echo "## ‚ö° Estado T√©cnico Unificado (Session State)"
        echo "\`\`\`json"
        if command -v jq >/dev/null 2>&1; then
            if [ "$optimize" = "true" ]; then
                # Remove itens pesados se optimize estiver ativo
                jq 'del(.rollback_stack) | del(.confidence_log) | del(.agent_queue)' "$unified_state_file"
            else
                # Otimizacao padr√£o: Mantem apenas os ultimos 3 checkpoints
                jq '.rollback_stack |= (if length > 3 then .[-3:] else . end)' "$unified_state_file"
            fi
        else
            cat "$unified_state_file"
        fi
        echo "\`\`\`"
        echo ""
    fi

    echo "## üöÄ Instru√ß√µes para o Pr√≥ximo Modelo"
    echo "1. Analise o estado atual, mas **AGUARDE** o comando do usu√°rio."
    echo "2. Carregue o **Estado T√©cnico Unificado** acima na sua mem√≥ria de trabalho."
    echo "3. O projeto usa o framework AI Dev Superpowers V3."
    echo "4. O √∫ltimo status conhecido foi: **$task**."
    echo "5. N√£o execute nenhuma a√ß√£o aut√¥noma at√© que o usu√°rio solicite."
    echo ""
    echo "------------------------------------------------"
    echo "--- SNAPSHOT END ---"
    echo ""

    print_success "Snapshot gerado com sucesso! Copie o bloco acima."
}

# Subcomando: agent
# Gera prompt de ativacao do modo agente para colar na IA
# Ativacao passiva de ultra-baixo custo (v6.3)
cmd_agent_lite() {
    local path="${1:-.}"
    local lite_file="$path/.aidev/.cache/activation_context.md"

    # Garante que o arquivo existe antes de mostrar
    load_module "context-compressor"
    context_compressor_generate "$lite_file" >/dev/null 2>&1

    if [ -f "$lite_file" ]; then
        cat "$lite_file"
        echo ""
        echo "---"
        echo "INSTRU√á√ÉO PARA IA: Voc√™ foi ativado no modo Zero-Shot."
        echo "Leia o contexto acima e use as ferramentas para investigar os detalhes se necess√°rio."
    else
        print_error "N√£o foi poss√≠vel gerar o contexto lite."
    fi
}

cmd_agent() {
    parse_args "$@"

    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")

    if ! has_aidev_installed "$install_path"; then
        print_error "AI Dev nao esta instalado neste diretorio"
        print_info "Execute 'aidev init' primeiro"
        exit 1
    fi

    # Coleta dados do projeto
    local project_name=$(detect_project_name "$install_path")
    [ -z "$project_name" ] && project_name="Sem Nome"
    local stack=$(detect_stack "$install_path")
    local platform=$(detect_platform)
    local fase=$(get_state_value "current_fase" "1")
    local sprint=$(get_state_value "current_sprint" "0")

    # Conta agentes e skills
    local agent_count=0
    local skill_count=0
    if [ -d "$install_path/.aidev/agents" ]; then
        agent_count=$(ls "$install_path/.aidev/agents"/*.md 2>/dev/null | wc -l)
    fi
    if [ -d "$install_path/.aidev/skills" ]; then
        skill_count=$(ls -d "$install_path/.aidev/skills"/*/ 2>/dev/null | wc -l)
    fi

    print_header "AI Dev Agent Mode"

    # Protocolo Zero-Shot (v4.1.1) - PADR√ÉO
    # S√≥ faz o dump completo se o usu√°rio pedir explicitamente --full
    if [ "$1" != "--full" ]; then
        cmd_agent_lite "$install_path"
        return 0
    fi

    shift # Consome --full
    print_info "Gerando prompt de ativa√ß√£o COMPLETO (Modo Legado)..."


    # Protocolo Zero-Shot (v6.3)
    # SE detectado MCP ou modo lite ativo, usa caminho otimizado
    if [ "$AIDEV_LITE" = "true" ] || [ -n "$ANTIGRAVITY_AGENT" ] || [ -n "$CLAUDE_CLI" ]; then
        cmd_agent_lite "$install_path"
        return 0
    fi
    print_info "Gerando prompt de ativacao..."
    echo ""

    # Verifica divergencia local vs global
    load_module "deploy-sync" 2>/dev/null || source "$AIDEV_LIB_DIR/deploy-sync.sh" 2>/dev/null || true
    deploy_sync_check_on_init

    # NOVO: Carrega Sprint Manager ANTES de usar
    load_module "sprint-manager"

    # NOVO: Sincroniza sprint_context para unified.json
    sprint_sync_to_unified "$install_path"

    # NOVO: Renderiza dashboard de sprint antes do prompt
    sprint_render_summary "$install_path"
    if [ -n "$(sprint_get_current "$install_path")" ]; then
        echo ""
        print_separator
        echo ""
    fi

    # Verifica se existe cache e carrega
    load_module "cache"
    local cache_content=""
    if validate_cache_freshness "$install_path"; then
        cache_content=$(get_cached_activation "$install_path")
    fi

    # Carrega estado da sess√£o (Continuity Context)
    local session_context=""
    local unified_file="$install_path/.aidev/state/unified.json"
    local active_intent=""
    local active_skill=""
    local last_activity=""
    
    if [ -f "$unified_file" ] && command -v jq >/dev/null 2>&1; then
        active_intent=$(jq -r '.active_intent // empty' "$unified_file")
        active_skill=$(jq -r '.active_skill // empty' "$unified_file")
        last_activity=$(jq -r '.session.last_activity // empty' "$unified_file")

        if [ -n "$active_intent" ] || [ -n "$active_skill" ]; then
            session_context="
CONTEXTO ATUAL (SESSAO ANTERIOR):
- Intencao Ativa: ${active_intent:-Nenhum}
- Skill em Uso: ${active_skill:-Nenhuma}
- Ultima Atividade: $last_activity

ATENCAO: VOCE DEVE CONTINUAR O TRABALHO ACIMA SE AINDA NAO ESTIVER CONCLUIDO.
NAO SUGIRA 'legacy-analyzer' OU NOVAS TAREFAS SE HOUVER UMA INTENCAO ATIVA.
"
        fi
    fi

    # NOVO: Carrega contexto de sprint
    local sprint_context=""
    if [ -f "$unified_file" ] && command -v jq >/dev/null 2>&1; then
        local sprint_id=$(jq -r '.sprint_context.sprint_id // "N/A"' "$unified_file" 2>/dev/null)
        local sprint_status=$(jq -r '.sprint_context.status // "N/A"' "$unified_file" 2>/dev/null)
        local completed=$(jq -r '.sprint_context.completed_tasks // 0' "$unified_file" 2>/dev/null)
        local total=$(jq -r '.sprint_context.total_tasks // 0' "$unified_file" 2>/dev/null)
        local progress=$(jq -r '.sprint_context.progress_percentage // 0' "$unified_file" 2>/dev/null)
        local next_desc=$(jq -r '.sprint_context.next_action.description // "Nenhuma a√ß√£o pendente"' "$unified_file" 2>/dev/null)

        if [ "$sprint_id" != "N/A" ] && [ "$sprint_id" != "null" ] && [ -n "$sprint_id" ]; then
            sprint_context="
CONTEXTO DA SPRINT:
- Sprint ID: $sprint_id
- Status: $sprint_status
- Progresso: $completed/$total tarefas ($progress%)
- Pr√≥xima A√ß√£o: $next_desc
"
        fi
    fi

    # Gera o prompt
    echo "============================================================"
    echo "COPIE E COLE O TEXTO ABAIXO NA SUA IA:"
    echo "============================================================"
    echo ""
    cat << EOF
ATIVAR MODO AGENTE - AI Dev Superpowers

Voce esta em um projeto com AI Dev Superpowers v3 instalado.

PROJETO: $project_name
STACK: $stack
FASE: $fase | SPRINT: $sprint
AGENTES: $agent_count especializados
SKILLS: $skill_count automatizadas
$session_context$sprint_context
EOF

    if [ -n "$cache_content" ]; then
        echo "‚ö†Ô∏è  CACHE DE ATIVACAO DETECTADO (OBRIGATORIO) ‚ö†Ô∏è"
        echo "\`\`\`json"
        echo "$cache_content"
        echo "\`\`\`"
        echo ""
        echo "üõë INSTRUCOES CRITICAS DE ECONOMIA DE TOKENS:"
        echo "1. USE O JSON ACIMA como sua √öNICA fonte de verdade sobre Agentes e Skills."
        echo "2. PROIBIDO LER arquivos individuais em .aidev/agents/ ou .aidev/skills/."
        echo "3. O JSON j√° cont√©m o 'role' (objetivo) de cada agente. N√ÉO RE-LEIA os arquivos .md."
        echo "4. O arquivo .aidev/rules/$stack.md tamb√©m j√° est√° resumido no cache."
        echo "5. S√≥ abra arquivos de c√≥digo do projeto quando solicitado pelo usu√°rio."
    else
        echo "INSTRUCOES DE ATIVACAO:"
        echo "1. Leia o arquivo .aidev/agents/orchestrator.md - este e seu cerebro de coordenacao"
        echo "2. Voce tem acesso a $agent_count agentes especializados em .aidev/agents/"
        echo "3. Voce tem acesso a $skill_count skills automatizadas em .aidev/skills/"
        echo "4. Siga as regras da stack em .aidev/rules/$stack.md"
    fi

    cat << EOF

PRINCIPIOS INEGOCIAVEIS:
- TDD OBRIGATORIO: Sempre escreva teste ANTES do codigo (RED -> GREEN -> REFACTOR)
- YAGNI: So implemente o que foi solicitado
- Commits atomicos com mensagens descritivas

FLUXO DE TRABALHO:
- Para novas features: brainstorming -> writing-plans -> test-driven-development -> code-review
- Para bugs: systematic-debugging -> learned-lesson
- Para refatoracao: writing-plans -> test-driven-development -> code-review

EOF

    # Se cache N√ÉO existe, lista agentes e skills individualmente
    if [ -z "$cache_content" ]; then
        cat << EOF

AGENTES DISPONIVEIS:
EOF

        # Lista agentes
        if [ -d "$install_path/.aidev/agents" ]; then
            for agent in "$install_path/.aidev/agents"/*.md; do
                if [ -f "$agent" ]; then
                    local name=$(basename "$agent" .md)
                    echo "- $name"
                fi
            done
        fi

        cat << EOF

SKILLS DISPONIVEIS:
EOF

        # Lista skills
        if [ -d "$install_path/.aidev/skills" ]; then
            for skill_dir in "$install_path/.aidev/skills"/*/; do
                if [ -d "$skill_dir" ]; then
                    local name=$(basename "$skill_dir")
                    echo "- $name"
                fi
            done
        fi
    fi

    cat << EOF

Confirme que voce entendeu e esta pronto para operar como orquestrador.
Responda: "Modo Agente ativado. Pronto para orquestrar."
EOF

    echo ""
    echo "============================================================"
    echo ""
    print_success "Prompt gerado! Cole na sua IA para ativar o modo agente."
    echo ""
    print_info "Dica: Use 'aidev agent | pbcopy' (macOS) ou 'aidev agent | xclip' (Linux) para copiar automaticamente"

    # NOVO: Sincroniza session.json legado
    load_module "state"
    state_sync_legacy_session
}

# Subcomando: cache
# Gerencia cache de ativa√ß√£o para economia de tokens
cmd_cache() {
    # N√£o usa parse_args pois --build/--clear s√£o espec√≠ficos deste subcomando
    local install_path="."
    local action="status"
    
    # Parse manual de argumentos
    for arg in "$@"; do
        case "$arg" in
            cache) ;; # ignora o pr√≥prio nome do comando
            --build|-b) action="build" ;;
            --clear|-c) action="clear" ;;
            --show|-s) action="show" ;;
            --install-in) ;; # handled next
            *)
                # Se o anterior foi --install-in, este √© o path
                if [[ "${prev_arg:-}" == "--install-in" ]]; then
                    install_path="$arg"
                fi
                ;;
        esac
        prev_arg="$arg"
    done

    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")

    if ! has_aidev_installed "$install_path"; then
        print_error "AI Dev n√£o est√° instalado neste diret√≥rio"
        print_info "Execute 'aidev init' primeiro"
        exit 1
    fi

    # Carrega m√≥dulo de cache
    load_module "cache"

    print_header "AI Dev Cache Manager"

    case "$action" in
        build)
            print_step "Construindo cache de ativa√ß√£o..."
            save_activation_cache "$install_path"
            print_success "Cache constru√≠do com sucesso!"
            show_cache_status "$install_path"
            ;;
        clear)
            print_step "Limpando cache..."
            invalidate_cache "$install_path"
            print_success "Cache removido!"
            ;;
        show)
            print_step "Conte√∫do do cache:"
            local cache_file="$install_path/$CACHE_DIR/$CACHE_FILE"
            if [ -f "$cache_file" ]; then
                print_cache_content "$install_path"
            else
                print_warning "Cache n√£o existe. Use 'aidev cache --build' para criar."
            fi
            ;;
        status|*)
            show_cache_status "$install_path"
            print_info "Op√ß√µes:"
            echo "  --build, -b   Constr√≥i/atualiza o cache"
            echo "  --clear, -c   Remove o cache"
            echo "  --show, -s    Exibe conte√∫do do cache (JSON)"
            ;;
    esac
}

# Subcomando: start
# Inicia sessao interativa do modo agente (exibe instrucoes de ativacao)
cmd_start() {
    parse_args "$@"

    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")

    if ! has_aidev_installed "$install_path"; then
        print_error "AI Dev nao esta instalado neste diretorio"
        print_info "Execute 'aidev init' primeiro"
        exit 1
    fi

    local project_name=$(detect_project_name "$install_path")
    local stack=$(detect_stack "$install_path")
    local platform=$(detect_platform)

    print_header "AI Dev Superpowers - Modo Agente"
    echo ""
    print_success "Projeto: $project_name"
    print_info "Stack: $stack | Plataforma: $platform"
    echo ""

    print_section "Como Ativar o Modo Agente"
    echo ""
    echo "  Opcao 1: Diga para sua IA:"
    printf "    ${CYAN}\"modo agente\"${NC} ou ${CYAN}\"aidev\"${NC} ou ${CYAN}\"superpowers\"${NC}\n"
    echo ""
    echo "  Opcao 2: Gere um prompt completo:"
    printf "    ${CYAN}aidev agent${NC}\n"
    echo ""
    echo "  Opcao 3: Cole o prompt diretamente:"
    printf "    ${CYAN}aidev agent | pbcopy${NC}  (macOS)\n"
    printf "    ${CYAN}aidev agent | xclip -selection clipboard${NC}  (Linux)\n"
    echo ""

    print_section "Agentes Disponiveis"
    if [ -d "$install_path/.aidev/agents" ]; then
        for agent in "$install_path/.aidev/agents"/*.md; do
            if [ -f "$agent" ]; then
                echo "  - $(basename "$agent" .md)"
            fi
        done
    fi
    echo ""

    print_section "Skills Disponiveis"
    if [ -d "$install_path/.aidev/skills" ]; then
        for skill_dir in "$install_path/.aidev/skills"/*/; do
            if [ -d "$skill_dir" ]; then
                echo "  - $(basename "$skill_dir")"
            fi
        done
    fi
    echo ""

    print_section "Proximos Passos"
    echo "  1. Abra sua IA (Claude Code, Cursor, etc.)"
    echo "  2. Diga 'modo agente' ou use 'aidev agent'"
    echo "  3. O orquestrador assumira o controle"
    echo ""
}

# Subcomando: lessons
# Gerencia base de conhecimento (KB)
cmd_lessons() {
    local subcommand="${1:-}"
    shift 2>/dev/null || true
    
    local install_path="."
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")
    
    case "$subcommand" in
        index)
            print_header "AI Dev KB - Indexador"
            build_lessons_index "$install_path"
            ;;
        search)
            local query="$1"
            if [ -z "$query" ]; then
                print_error "Uso: aidev lessons search \"termo\""
                exit 1
            fi
            print_header "AI Dev KB - Busca"
            search_lessons_formatted "$query" "$install_path"
            ;;
        list|"")
            # Comportamento original (legado) ou listagem simples
            print_header "AI Dev KB - Li√ß√µes"
            local kb_dir="$install_path/.aidev/memory/kb"
            if [ -d "$kb_dir" ]; then
                ls -1 "$kb_dir"/*.md 2>/dev/null | xargs -n 1 basename -s .md | sed 's/^/  ‚Ä¢ /'
            else
                print_info "Nenhuma li√ß√£o encontrada."
            fi
            ;;
        *)
            print_error "Subcomando desconhecido: $subcommand"
            echo "Uso: aidev lessons [list|index|search]"
            exit 1
            ;;
    esac
}

# Subcomando: metrics
# Exibe dashboard de telemetria
cmd_metrics() {
    parse_args "$@"
    
    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")
    local metrics_file="$install_path/.aidev/state/metrics.log"
    
    print_header "AI Dev Telemetry & Metrics"
    
    if [ ! -f "$metrics_file" ]; then
        print_warning "Nenhuma m√©trica coletada ainda."
        exit 0
    fi
    
    print_info "Fonte: $metrics_file"
    echo ""
    
    # Verifica depend√™ncia jq
    if ! command -v jq >/dev/null 2>&1; then
        print_error "jq √© necess√°rio para visualizar m√©tricas."
        exit 1
    fi
    
    print_section "Resumo de Skills"
    # Agrega por nome de skill: count, avg duration, success count
    cat "$metrics_file" | jq -r 'select(.type=="skill_execution")' | \
    jq -s 'group_by(.name) | .[] | {
        name: .[0].name, 
        count: length, 
        avg_duration: (map(.duration)|add/length|floor), 
        success: (map(select(.status=="completed"))|length),
        failed: (map(select(.status=="failed"))|length)
    }' | \
    jq -r '"  ‚Ä¢ \(.name): \(.count) execu√ß√µes | M√©dia: \(.avg_duration)ms | ‚úì \(.success) | ‚úó \(.failed)"'
    
    echo ""
    print_section "Atividade de Agentes"
    # Agrega por agente
    cat "$metrics_file" | jq -r 'select(.type=="agent_activate")' | \
    jq -s 'group_by(.name) | .[] | {name: .[0].name, count: length}' | \
    jq -r '"  ‚Ä¢ \(.name): \(.count) ativa√ß√µes"'
    
    echo ""
    print_success "Dashboard atualizado."
}

# Subcomando: doctor
# Diagn√≥stico da instala√ß√£o e ambiente com sugest√µes de reparo
cmd_doctor() {
    local fix_mode=false
    local filtered_args=()
    
    for arg in "$@"; do
        if [ "$arg" == "--fix" ]; then
            fix_mode=true
        else
            filtered_args+=("$arg")
        fi
    done

    # Parse remaining args
    parse_args "${filtered_args[@]}"
    
    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")
    
    # Detecta instala√ß√£o global
    local global_install=""
    local aidev_path=$(which aidev 2>/dev/null || echo "")
    if [ -n "$aidev_path" ]; then
        if [ -L "$aidev_path" ]; then
            local real_path=$(readlink -f "$aidev_path")
            global_install=$(dirname "$(dirname "$real_path")")
        else
            global_install=$(dirname "$(dirname "$aidev_path")")
        fi
    fi
    
    print_header "AI Dev Doctor"
    
    local issues=0
    local warnings=0

    # 1. Depend√™ncias do Sistema (Core)
    print_section "Dependencias do Sistema"
    local deps=("git" "jq" "bash" "sed" "grep")
    for dep in "${deps[@]}"; do
        if command -v "$dep" >/dev/null 2>&1; then
            print_success "$dep: $(command -v "$dep")"
        else
            if [ "$dep" == "jq" ]; then
                print_warning "$dep: NAO ENCONTRADO (usando fallback Bash)"
                ((warnings++)) || true
            else
                print_error "$dep: NAO ENCONTRADO"
                ((issues++)) || true
            fi
        fi
    done

    # 1.1 Depend√™ncias MCP (para servidores MCP funcionarem)
    print_section "Dependencias MCP"

    # Node.js / npx (para Context7)
    if command -v node >/dev/null 2>&1; then
        local node_version=$(node --version 2>/dev/null)
        print_success "node: $node_version"
        if command -v npx >/dev/null 2>&1; then
            print_success "npx: $(command -v npx)"
        else
            print_warning "npx: NAO ENCONTRADO (Context7 MCP nao funcionara)"
            ((warnings++)) || true
        fi
    else
        print_warning "node: NAO ENCONTRADO (Context7 MCP nao funcionara)"
        ((warnings++)) || true
    fi

    # Python / uvx (para Serena e basic-memory)
    if command -v python3 >/dev/null 2>&1; then
        local python_version=$(python3 --version 2>/dev/null)
        print_success "python3: $python_version"
    else
        print_warning "python3: NAO ENCONTRADO"
        ((warnings++)) || true
    fi

    if command -v uvx >/dev/null 2>&1; then
        print_success "uvx: $(command -v uvx)"
    elif command -v uv >/dev/null 2>&1; then
        print_success "uv: $(command -v uv) (uvx disponivel via 'uv tool run')"
    else
        print_warning "uvx/uv: NAO ENCONTRADO (Serena e basic-memory MCP nao funcionarao)"
        print_info "Instale com: curl -LsSf https://astral.sh/uv/install.sh | sh"
        ((warnings++)) || true
    fi
    
    # 2. Verifica instala√ß√£o
    print_section "Verificando Instala√ß√£o"
    if has_aidev_installed "$install_path"; then
        print_success ".aidev/ existe"
        
        # Verifica diret√≥rios
        local dirs=("agents" "skills" "rules" "state" "memory/kb")
        for dir in "${dirs[@]}"; do
            if [ -d "$install_path/.aidev/$dir" ]; then
                print_success ".aidev/$dir/ existe"
            else
                if [ "$fix_mode" = "true" ]; then
                    print_info "$(_ "fix_recreating_dir") .aidev/$dir/"
                    ensure_dir "$install_path/.aidev/$dir"
                    print_success ".aidev/$dir/ $(_ "fix_created")"
                else
                    print_warning ".aidev/$dir/ n√£o encontrado"
                    ((warnings++)) || true
                fi
            fi
        done
    else
        print_error ".aidev/ n√£o encontrado em $install_path"
        if [ "$fix_mode" = "true" ]; then
            print_info "$(_ "fix_restoring_base")"
            create_base_structure "$install_path"
            print_success "$(_ "fix_restored")"
        else
            ((issues++)) || true
        fi
    fi
    
    # 3. Estado da Sess√£o
    print_section "Estado da Sess√£o"
    local state_file="$install_path/.aidev/state/session.json"
    if [ -f "$state_file" ]; then
        if command -v jq >/dev/null 2>&1 && ! jq . "$state_file" >/dev/null 2>&1; then
            print_error "Arquivo session.json corrompido"
            ((issues++)) || true
        else
            print_success "Arquivo session.json √≠ntegro"
        fi
    else
        print_info "session.json ainda n√£o inicializado"
    fi
    
    # 4. Segredos e Seguran√ßa
    print_section "Segredos e Seguranca"
    local env_file="$install_path/.env"
    if [ -f "$env_file" ]; then
        load_env "$env_file"
        if [ -n "${CONTEXT7_API_KEY:-}" ]; then
            print_success "Context7 API Key configurada"
        else
            print_warning "Context7 API Key ausente no .env"
            ((warnings++)) || true
        fi
        
        # Verifica se .env est√° no gitignore
        if [ -f "$install_path/.gitignore" ]; then
            if grep -q "^\.env" "$install_path/.gitignore" || grep -q "/\.env" "$install_path/.gitignore"; then
                print_success ".env protegido no .gitignore"
            else
                if [ "$fix_mode" = "true" ]; then
                    print_info "$(_ "fix_protecting_env")"
                    echo ".env" >> "$install_path/.gitignore"
                    print_success "$(_ "fix_protected_env")"
                else
                    print_error ".env N√ÉO est√° no .gitignore (RISCO DE EXPOSI√á√ÉO)"
                    ((issues++)) || true
                fi
            fi
        fi
    else
        print_info ".env nao encontrado (opcional, mas recomendado para MCP)"
    fi

    # 4.1 Verificacao de sincronizacao MCP
    print_section "Sincronizacao MCP"
    local mcp_file="$install_path/.mcp.json"
    if [ -f "$mcp_file" ]; then
        if command -v jq >/dev/null 2>&1; then
            local mcp_key=$(jq -r '.mcpServers.context7.env.CONTEXT7_API_KEY // empty' "$mcp_file" 2>/dev/null)
            local env_key="${CONTEXT7_API_KEY:-}"

            if [ -n "$env_key" ] && [ -n "$mcp_key" ]; then
                if [ "$env_key" = "$mcp_key" ]; then
                    print_success ".mcp.json sincronizado com .env"
                else
                    print_warning ".mcp.json desatualizado (API Key diferente do .env)"
                    if [ "$fix_mode" = "true" ]; then
                        print_info "Regenerando .mcp.json..."
                        AIDEV_FORCE=true
                        configure_mcp "$install_path" "$(detect_platform)"
                        print_success ".mcp.json atualizado!"
                    else
                        print_info "Execute 'aidev doctor --fix' para sincronizar"
                    fi
                    ((warnings++)) || true
                fi
            elif [ -n "$env_key" ] && [ -z "$mcp_key" ]; then
                print_warning ".mcp.json nao tem API Key configurada"
                if [ "$fix_mode" = "true" ]; then
                    print_info "Regenerando .mcp.json..."
                    AIDEV_FORCE=true
                    configure_mcp "$install_path" "$(detect_platform)"
                    print_success ".mcp.json atualizado!"
                fi
                ((warnings++)) || true
            elif [ -z "$env_key" ]; then
                print_info "API Key nao configurada (Context7 pode nao funcionar)"
            fi
        else
            print_info ".mcp.json existe (jq nao disponivel para validar sincronizacao)"
        fi
    else
        print_info ".mcp.json nao encontrado"
    fi

    # 4.2 Verifica√ß√£o de Portabilidade (Caminhos Absolutos)
    print_section "Portabilidade e Caminhos"
    local home_pattern="/home/[^/ /]+"
    local found_abs_paths=0
    local sync_file="$install_path/.aidev/mcp/memory-sync.json"
    
    if [ -f "$mcp_file" ] && grep -qE "$home_pattern" "$mcp_file"; then
        print_warning ".mcp.json cont√©m caminhos absolutos (dificulta portabilidade)"
        found_abs_paths=1
    fi
    
    if [ -f "$sync_file" ] && grep -qE "$home_pattern" "$sync_file"; then
        print_warning "memory-sync.json cont√©m caminhos absolutos"
        found_abs_paths=1
    fi
    
    if [ $found_abs_paths -eq 1 ]; then
        if [ "$fix_mode" = "true" ]; then
            print_info "Normalizando caminhos para portabilidade..."
            [ -f "$mcp_file" ] && sed -i "s|/home/[^/ \"]*|\$HOME|g" "$mcp_file"
            [ -f "$sync_file" ] && sed -i "s|/home/[^/ \"]*|\$HOME|g" "$sync_file"
            print_success "Caminhos normalizados com \$HOME!"
        else
            print_info "Dica: Use 'aidev doctor --fix' para converter caminhos absolutos em \$HOME"
            ((warnings++)) || true
        fi
    else
        print_success "Configura√ß√µes de caminhos parecem port√°teis"
    fi

    # 5. Contexto
    print_section "Contexto Detectado"
    local platform=$(detect_platform)
    local stack=$(detect_stack "$install_path")
    print_info "Plataforma: $platform"
    print_info "Stack:      $stack"

    # 6. Verifica√ß√£o de Integridade Cr√≠tica
    print_section "Integridade do Sistema"
    local critical_dirs=(".aidev/agents" ".aidev/skills" ".aidev/rules")
    
    # O diret√≥rio bin s√≥ √© vital na instala√ß√£o global
    if [ "$install_path" = "$global_install" ] || [ "$install_path" = "/usr/local" ]; then
        critical_dirs+=("bin")
    fi
    
    for dir in "${critical_dirs[@]}"; do
        if [ -d "$install_path/$dir" ]; then
            print_success "Diret√≥rio vital ok: $dir"
        else
            print_error "DIRET√ìRIO VITAL AUSENTE: $dir"
            ((issues++)) || true
        fi
    done

    # 5. Sugest√µes de Reparo
    if [ $issues -gt 0 ] || [ $warnings -gt 0 ]; then
        print_section "Sugest√µes de Reparo"
        if ! command -v jq >/dev/null 2>&1; then
            echo -e "  ‚Ä¢ ${YELLOW}Instalar jq:${NC} sudo apt install jq  (ou brew install jq)"
        fi
        if ! command -v git >/dev/null 2>&1; then
            echo -e "  ‚Ä¢ ${RED}Instalar git:${NC} sudo apt install git"
        fi
        if [ ! -d "$install_path/.aidev" ]; then
            echo -e "  ‚Ä¢ ${CYAN}Inicializar Projeto:${NC} aidev init"
        fi
        if [ -f "$install_path/.env" ] && [ -z "${CONTEXT7_API_KEY:-}" ]; then
            echo -e "  ‚Ä¢ ${YELLOW}Context7:${NC} Adicione CONTEXT7_API_KEY ao seu arquivo .env"
        fi
    fi

    echo ""
    if [ $issues -eq 0 ]; then
        if [ $warnings -eq 0 ]; then
            print_success "Tudo limpo! Seu ambiente est√° saud√°vel."
        else
            print_info "Ambiente operacional, mas com $warnings avisos."
        fi
    else
        print_error "Encontrados $issues problemas cr√≠ticos. Verifique as mensagens acima."
    fi

    # 7. Sugest√µes de Ecossistema (SGAITI v3.8)
    if [ -f "$install_path/.aidev/plans/ROADMAP.md" ]; then
        load_module "mcp-bridge" 2>/dev/null || source "$AIDEV_LIB_DIR/mcp-bridge.sh"
        mcp_bridge_suggest
    fi
    echo ""
}

# ============================================================================
# Fun√ß√µes de Instala√ß√£o
# ============================================================================

# Cria estrutura base de diret√≥rios
create_base_structure() {
    local path="$1"
    
    ensure_dir "$path/.aidev"
    ensure_dir "$path/.aidev/agents"
    ensure_dir "$path/.aidev/skills"
    ensure_dir "$path/.aidev/rules"
    ensure_dir "$path/.aidev/state"
    ensure_dir "$path/.aidev/memory/kb"
    ensure_dir "$path/.aidev/analysis"
    ensure_dir "$path/.aidev/lib"
    
    # Copia bibliotecas auxiliares do projeto (v4.2.0)
    # Sprint 6.2: Feature Lifecycle precisa estar dispon√≠vel no projeto
    if [ -f "$AIDEV_ROOT_DIR/.aidev/lib/feature-lifecycle.sh" ]; then
        cp "$AIDEV_ROOT_DIR/.aidev/lib/feature-lifecycle.sh" "$path/.aidev/lib/"
        chmod +x "$path/.aidev/lib/feature-lifecycle.sh"
    fi
}

# Instala agentes a partir dos templates com suporte a overrides por plataforma
# Instala agentes a partir dos templates com suporte a overrides por plataforma
install_agents() {
    local path="$1"
    local agents_dir="$path/.aidev/agents"
    local lang_suffix=$(get_lang_suffix 2>/dev/null || echo "pt")
    
    # Exporta vari√°veis para os templates
    export PROJECT_NAME=$(detect_project_name "$path")
    export STACK="$CLI_STACK"
    export PLATFORM="$CLI_PLATFORM"

    local base_dir="$AIDEV_ROOT_DIR/templates/agents"
    local lang_dir="$base_dir/$lang_suffix"
    local platform_dir="$AIDEV_ROOT_DIR/templates/platform/$CLI_PLATFORM/agents"
    local platform_lang_dir="$platform_dir/$lang_suffix"

    # Itera sobre todos os templates na raiz de agentes
    if [ -d "$base_dir" ]; then
        for template in "$base_dir"/*.md.tmpl; do
            [ -f "$template" ] || continue
            local name=$(basename "$template" .md.tmpl)
            
            # Ordem de preced√™ncia (mais espec√≠fico para menos espec√≠fico):
            # 1. Plataforma + Idioma
            # 2. Plataforma
            # 3. Idioma
            # 4. Base
            local template_to_use="$template"
            
            if [ -f "$lang_dir/${name}.md.tmpl" ]; then
                template_to_use="$lang_dir/${name}.md.tmpl"
            fi
            
            if [ -f "$platform_dir/${name}.md.tmpl" ]; then
                template_to_use="$platform_dir/${name}.md.tmpl"
            fi
            
            if [ -f "$platform_lang_dir/${name}.md.tmpl" ]; then
                template_to_use="$platform_lang_dir/${name}.md.tmpl"
            fi

            local output="$agents_dir/${name}.md"
            if should_write_file "$output"; then
                process_template "$template_to_use" "$output"
                print_debug "Instalado agente: $name (de $(basename "$(dirname "$template_to_use")")/$(basename "$template_to_use"))"
            fi
        done
    fi
}

process_agent_template() {
    local template="$1"
    local output_dir="$2"
    local platform_dir="$3"
    
    local name=$(basename "$template" .md.tmpl)
    local output="$output_dir/${name}.md"
    
    # Verifica override
    local template_to_use="$template"
    if [ -n "$CLI_PLATFORM" ] && [ -f "$platform_dir/${name}.md.tmpl" ]; then
        template_to_use="$platform_dir/${name}.md.tmpl"
        print_debug "Usando override de plataforma para: $name"
    fi
    
    if should_write_file "$output"; then
        process_template "$template_to_use" "$output"
        print_debug "Instalado: $name"
    fi
}

# Instala skills a partir dos templates
install_skills() {
    local path="$1"
    local skills_dir="$path/.aidev/skills"
    
    for skill_template_dir in "$AIDEV_ROOT_DIR/templates/skills"/*/; do
        if [ -d "$skill_template_dir" ]; then
            local skill_name=$(basename "$skill_template_dir")
            local output_dir="$skills_dir/$skill_name"
            
            ensure_dir "$output_dir"
            
            for template in "$skill_template_dir"/*.tmpl; do
                if [ -f "$template" ]; then
                    local name=$(basename "$template" .tmpl)
                    local output="$output_dir/$name"
                    
                    if should_write_file "$output"; then
                        process_template "$template" "$output"
                    fi
                fi
            done
        fi
    done
}

# Instala rules a partir dos templates
install_rules() {
    local path="$1"
    local stack="$2"
    local rules_dir="$path/.aidev/rules"
    local lang_suffix=$(get_lang_suffix 2>/dev/null || echo "pt")
    
    # Busca templates localizados (ex: templates/rules/pt/generic.md.tmpl)
    # Tenta: localized -> legacy/root
    
    local generic_template="$AIDEV_ROOT_DIR/templates/rules/$lang_suffix/generic.md.tmpl"
    if [ ! -f "$generic_template" ]; then
        generic_template="$AIDEV_ROOT_DIR/templates/rules/generic.md.tmpl"
    fi

    if [ -f "$generic_template" ]; then
        local output="$rules_dir/generic.md"
        if should_write_file "$output"; then
            process_template "$generic_template" "$output"
        fi
    fi

    # Instala rule espec√≠fica da stack
    local stack_template="$AIDEV_ROOT_DIR/templates/rules/$lang_suffix/${stack}.md.tmpl"
    if [ ! -f "$stack_template" ]; then
        stack_template="$AIDEV_ROOT_DIR/templates/rules/${stack}.md.tmpl"
    fi

    if [ -f "$stack_template" ]; then
        local output="$rules_dir/${stack}.md"
        if should_write_file "$output"; then
            process_template "$stack_template" "$output"
        fi
    fi
}

# Instala LLM limits (guardrails de execucao)
install_llm_limits() {
    local path="$1"
    local rules_dir="$path/.aidev/rules"
    local lang_suffix=$(get_lang_suffix 2>/dev/null || echo "pt")

    local llm_template="$AIDEV_ROOT_DIR/templates/rules/$lang_suffix/llm-limits.md.tmpl"
    if [ ! -f "$llm_template" ]; then
        llm_template="$AIDEV_ROOT_DIR/templates/rules/llm-limits.md.tmpl"
    fi

    if [ -f "$llm_template" ]; then
        ensure_dir "$rules_dir"
        local output="$rules_dir/llm-limits.md"
        if should_write_file "$output"; then
            process_template "$llm_template" "$output"
        fi
    fi
}

# Configura MCP
configure_mcp() {
    local path="$1"
    local platform="$2"

    # Carrega m√≥dulo MCP se n√£o carregado
    load_module "mcp" 2>/dev/null || true

    # Setup completo do MCP Engine
    setup_mcp_engine "$path" "$platform"
}

# Instala estrutura de planos e roadmaps (v4.3.0)
# Cria estrutura completa: backlog/, features/, current/, history/, archive/
install_plans() {
    local path="$1"
    local plans_dir="$path/.aidev/plans"
    
    # Cria todas as pastas da estrutura organizada
    ensure_dir "$plans_dir"
    ensure_dir "$plans_dir/backlog"
    ensure_dir "$plans_dir/features"
    ensure_dir "$plans_dir/current"
    ensure_dir "$plans_dir/history"
    ensure_dir "$plans_dir/archive"
    
    # Processa ROADMAP.md
    local roadmap_template="$AIDEV_ROOT_DIR/templates/plans/ROADMAP.md.tmpl"
    if [ -f "$roadmap_template" ]; then
        process_template "$roadmap_template" "$plans_dir/ROADMAP.md"
        print_debug "Instalado ROADMAP.md inicial"
    fi
    
    # Processa READMEs de cada pasta
    local readme_templates=(
        "README.md:"
        "backlog/README.md:backlog/"
        "features/README.md:features/"
        "current/README.md:current/"
        "history/README.md:history/"
        "archive/README.md:archive/"
    )
    
    for item in "${readme_templates[@]}"; do
        local template_file="${item%%:*}"
        local output_subdir="${item#*:}"
        local template_path="$AIDEV_ROOT_DIR/templates/plans/$template_file.tmpl"
        local output_path="$plans_dir/$output_subdir/README.md"
        
        if [ -f "$template_path" ]; then
            process_template "$template_path" "$output_path"
            print_debug "Instalado $output_subdir/README.md"
        fi
    done
    
    print_info "Estrutura de planos criada"
}

# Atualiza estrutura de planos em projetos legados (v4.3.0)
# Verifica se a estrutura completa existe e cria se necess√°rio
upgrade_plans_structure() {
    local path="$1"
    local plans_dir="$path/.aidev/plans"
    
    # Verifica se diret√≥rio de planos existe
    if [ ! -d "$plans_dir" ]; then
        print_debug "Diret√≥rio de planos n√£o encontrado, pulando upgrade"
        return 0
    fi
    
    print_info "Verificando estrutura de planos..."

    # Diret√≥rios necess√°rios para estrutura de planos
    local required_dirs=("backlog" "features" "current" "history" "archive")
    local created_count=0
    
    for dir in "${required_dirs[@]}"; do
        if [ ! -d "$plans_dir/$dir" ]; then
            ensure_dir "$plans_dir/$dir"
            print_success "Criado: .aidev/plans/$dir/"
            created_count=$((created_count + 1))
        fi
    done
    
    # Verifica e cria READMEs
    local readme_templates=(
        "README.md:."
        "backlog/README.md:backlog"
        "features/README.md:features"
        "current/README.md:current"
        "history/README.md:history"
        "archive/README.md:archive"
    )
    
    for item in "${readme_templates[@]}"; do
        local template_file="${item%%:*}"
        local output_dir="${item#*:}"
        local template_path="$AIDEV_ROOT_DIR/templates/plans/$template_file.tmpl"
        local output_path="$plans_dir/$output_dir/README.md"
        
        # S√≥ cria se o template existir e o README n√£o existir
        if [ -f "$template_path" ] && [ ! -f "$output_path" ]; then
            process_template "$template_path" "$output_path"
            print_success "Criado: .aidev/plans/$output_dir/README.md"
            created_count=$((created_count + 1))
        fi
    done
    
    # Cria/atualiza VERSION se n√£o existir
    if [ ! -f "$path/VERSION" ]; then
        echo "${AIDEV_VERSION:-4.4.1}" > "$path/VERSION"
        print_success "Criado: VERSION"
    fi
    
    if [ $created_count -gt 0 ]; then
        print_info "Estrutura de planos atualizada ($created_count itens criados)"
    else
        print_debug "Estrutura de planos j√° est√° atualizada"
    fi
}

# Instala instru√ß√µes de plataforma (lembrete de ativa√ß√£o)


# Instala workflows do Antigravity (v4.0.1)
install_antigravity_workflows() {
    local path="$1"
    local workflows_src="$AIDEV_ROOT_DIR/templates/platform/antigravity/workflows"
    local workflows_dest="$path/.agent/workflows"

    if [ -d "$workflows_src" ]; then
        ensure_dir "$workflows_dest"
        
        # Copia todos os arquivos .md do template para o destino
        for f in "$workflows_src"/*.md; do
            if [ -f "$f" ]; then
                local filename=$(basename "$f")
                if should_write_file "$workflows_dest/$filename"; then
                    cp "$f" "$workflows_dest/$filename"
                    increment_files
                    print_debug "Workflow instalado: $filename"
                fi
            fi
        done
        print_success "Workflows do Antigravity instalados em .agent/workflows/"
    fi
}

install_platform_instructions() {
    local path="$1"
    local platform="$2"

    # Exporta vari√°veis para templates
    export PROJECT_NAME=$(detect_project_name "$path")
    export STACK="$CLI_STACK"

    local templates_dir="$AIDEV_ROOT_DIR/templates/platform"

    # Sempre instala o arquivo gen√©rico AI_INSTRUCTIONS.md em .aidev/
    local generic_template="$templates_dir/AI_INSTRUCTIONS.md.tmpl"
    if [ -f "$generic_template" ]; then
        local output="$path/.aidev/AI_INSTRUCTIONS.md"
        if should_write_file "$output"; then
            process_template "$generic_template" "$output"
            print_debug "Instru√ß√µes gen√©ricas: AI_INSTRUCTIONS.md"
        fi
    fi

    # Sempre instala o QUICKSTART.md consolidado em .aidev/
    local quickstart_template="$templates_dir/QUICKSTART.md.tmpl"
    if [ -f "$quickstart_template" ]; then
        local output="$path/.aidev/QUICKSTART.md"
        if should_write_file "$output"; then
            process_template "$quickstart_template" "$output"
            print_success "Criado: .aidev/QUICKSTART.md (ativacao rapida)"
        fi
    fi

    # Instala arquivo espec√≠fico da plataforma na raiz do projeto
    case "$platform" in
        "claude-code")
            local template="$templates_dir/CLAUDE.md.tmpl"
            local output="$path/CLAUDE.md"
            if [ -f "$template" ] && should_write_file "$output"; then
                process_template "$template" "$output"
                print_success "Criado: CLAUDE.md (lembrete de ativa√ß√£o)"
            fi
            ;;
        "cursor")
            local template="$templates_dir/cursorrules.tmpl"
            local output="$path/.cursorrules"
            if [ -f "$template" ] && should_write_file "$output"; then
                process_template "$template" "$output"
                print_success "Criado: .cursorrules (lembrete de ativa√ß√£o)"
            fi
            ;;
        "gemini")
            local template="$templates_dir/GEMINI.md.tmpl"
            local output="$path/GEMINI.md"
            if [ -f "$template" ] && should_write_file "$output"; then
                process_template "$template" "$output"
                print_success "Criado: GEMINI.md (lembrete de ativa√ß√£o)"
            fi
            ;;
        "aider")
            local template="$templates_dir/AIDER.md.tmpl"
            local output="$path/AIDER.md"
            if [ -f "$template" ] && should_write_file "$output"; then
                process_template "$template" "$output"
                print_success "Criado: AIDER.md (lembrete de ativa√ß√£o)"
            fi
            ;; 

        "antigravity")
            # Workflows espec√≠ficos do Antigravity (v4.0.1)
            install_antigravity_workflows "$path"
            
            local template="$templates_dir/ANTIGRAVITY.md.tmpl"
            local output="$path/ANTIGRAVITY.md"
            if [ -f "$template" ] && should_write_file "$output"; then
                process_template "$template" "$output"
                print_success "Criado: ANTIGRAVITY.md (lembrete de ativa√ß√£o)"
            fi
            ;;
        *)
            # Para plataformas gen√©ricas, cria um arquivo na raiz
            local template="$templates_dir/AI_INSTRUCTIONS.md.tmpl"
            local output="$path/AI_INSTRUCTIONS.md"
            if [ -f "$template" ] && should_write_file "$output"; then
                process_template "$template" "$output"
                print_success "Criado: AI_INSTRUCTIONS.md (lembrete de ativa√ß√£o)"
            fi
            ;;
    esac
}

# Instala configura√ß√£o de Memory Sync
install_memory_sync() {
    local path="$1"
    local output="$path/.aidev/mcp/memory-sync.json"
    local template="$AIDEV_ROOT_DIR/templates/mcp/memory-sync.json.tmpl"
    
    if [ -f "$template" ] && should_write_file "$output"; then
        export CROSS_PROJECT_ENABLED="false"
        export HOME="$HOME"
        process_template "$template" "$output"
        print_success "Configurado: .aidev/mcp/memory-sync.json"
    fi
}

# Instala triggers de captura de li√ß√µes
install_triggers() {
    local path="$1"
    local output_dir="$path/.aidev/triggers"
    local template_dir="$AIDEV_ROOT_DIR/templates/triggers"
    
    ensure_dir "$output_dir"
    
    if [ -d "$template_dir" ]; then
        for template in "$template_dir"/*.tmpl; do
            if [ -f "$template" ]; then
                local name=$(basename "$template" .tmpl)
                local output="$output_dir/$name"
                if should_write_file "$output"; then
                    process_template "$template" "$output"
                    print_debug "Instalado trigger: $name"
                fi
            fi
        done
    fi
    echo ""
    print_success "Configura√ß√£o de triggers instalada com sucesso!"
}


# ============================================================================
# Subcomando: system
# ============================================================================
# Gest√£o de deploy e sincroniza√ß√£o global
cmd_system() {
    load_module "system"
    # Captura argumentos
    local subcmd="${1:-status}"
    shift || true
    
    case "$subcmd" in
        status)
            system__status
            ;;
        deploy)
            # Confirma√ß√£o simples
            echo ""
            echo -n "‚ö†Ô∏è  Deseja realizar o deploy para a instala√ß√£o global? (s/N): "
            read -r confirm
            if [[ "$confirm" =~ ^[sS] ]]; then
                system__deploy
            else
                print_info "Opera√ß√£o cancelada."
            fi
            ;;
        link)
            system__link
            ;;
        rollback)
            system__rollback
            ;;
        sync)
            # Sincroniza√ß√£o local ‚Üí global
            load_module "deploy-sync" 2>/dev/null || source "$AIDEV_LIB_DIR/deploy-sync.sh"
            
            local sync_option="${1:-}"
            
            case "$sync_option" in
                --check|-c)
                    deploy_sync_check_divergence "." || true
                    ;;
                --dry-run|-d)
                    deploy_sync_to_global "." "--dry-run"
                    ;;
                *)
                    echo ""
                    echo "üîÑ Sincroniza√ß√£o: Local ‚Üí Global"
                    echo ""
                    
                    # Primeiro verifica se h√° diverg√™ncia
                    if deploy_sync_check_divergence "." 2>/dev/null; then
                        echo "‚úÖ J√° est√° sincronizado!"
                        return 0
                    fi
                    
                    echo ""
                    echo -n "‚ö†Ô∏è  Confirma sincroniza√ß√£o? (s/N): "
                    read -r confirm
                    if [[ "$confirm" =~ ^[sS] ]]; then
                        deploy_sync_to_global "."
                    else
                        print_info "Opera√ß√£o cancelada."
                    fi
                    ;;
            esac
            ;;
        *)
            print_error "A√ß√£o desconhecida: $subcmd"
            echo "Uso: aidev system [status|deploy|link|sync]"
            echo ""
            echo "Comandos sync:"
            echo "  aidev system sync          # Sincroniza local ‚Üí global"
            echo "  aidev system sync --check  # Verifica diverg√™ncia apenas"
            echo "  aidev system sync --dry-run # Simula sincroniza√ß√£o"
            exit 1
            ;;
    esac
}

# ============================================================================
# Subcomando: roadmap
# ============================================================================
cmd_roadmap() {
    local subcmd="${1:-status}"
    shift || true

    load_module "plans" 2>/dev/null || source "$AIDEV_LIB_DIR/plans.sh"
    load_module "state" 2>/dev/null || source "$AIDEV_LIB_DIR/state.sh"

    case "$subcmd" in
        status)
            print_header "AI Dev - Dashboard de Progresso"
            if [ -f ".aidev/plans/ROADMAP.md" ]; then
                # Exibe vers√£o e objetivo
                local current_ver=$(grep "Vers√£o Atual" ".aidev/plans/ROADMAP.md" | head -n 1 | sed 's/.*: //')
                local objective=$(sed -n '/## üéØ OBJETIVO/,/---/p' ".aidev/plans/ROADMAP.md" | grep -v "##" | grep -v -- "---" | xargs)
                
                print_info "Vers√£o: $current_ver"
                print_info "Meta:   $objective"
                echo ""

                # C√°lculo de Progresso Geral da Sprint Atual
                local total_tasks=0 done_tasks=0 progress=0
                total_tasks=$(grep -A 50 -E "EM CURSO|EM PROGRESSO" ".aidev/plans/ROADMAP.md" 2>/dev/null | grep -cE "^- \[[x ]\]") || true
                done_tasks=$(grep -A 50 -E "EM CURSO|EM PROGRESSO" ".aidev/plans/ROADMAP.md" 2>/dev/null | grep -cE "^- \[x\]") || true
                [[ $total_tasks -gt 0 ]] && progress=$(( (done_tasks * 100) / total_tasks ))

                echo -n "  Progresso da Sprint: "
                print_progress "$progress" 30 "full"

                # Estado do Agente (Unified State)
                local active_skill=$(state_read "active_skill" "Nenhuma")
                local active_task=$(get_state_value "current_task" "Pendente")

                print_section "Fase em Execu√ß√£o"
                echo "  Skill Ativa:  ${CYAN}${active_skill}${NC}"
                echo "  Tarefa Atual: ${YELLOW}${active_task}${NC}"
                echo ""

                # Exibe as tarefas da Sprint (se houver sprint em curso)
                grep -A 20 "EM CURSO" ".aidev/plans/ROADMAP.md" 2>/dev/null | grep -E "^- \[[x ]\]" | head -n 10 || true
                
                # Lista funcionalidades r√°pidas
                plans__feature_list
                
                echo ""
                print_info "Para detalhes completos, veja: .aidev/plans/ROADMAP.md"
            else
                print_error "ROADMAP.md n√£o encontrado. Use 'aidev init' para provisionar."
            fi
            ;;
        list|features)
            plans__feature_list
            ;;
        *)
            print_error "Subcomando desconhecido: $subcmd (status, list)"
            exit 1
            ;;
    esac
}

# ============================================================================
# Subcomando: mcp
# ============================================================================
# Gerencia e orquestra servidores MCP
cmd_mcp() {
    # N√ÉO fazer shift aqui - main() j√° consumiu 'mcp'
    local subcommand="${1:-status}"
    shift 2>/dev/null || true

    load_module "mcp-bridge" 2>/dev/null || source "$AIDEV_LIB_DIR/mcp-bridge.sh"
    
    case "$subcommand" in
        status|suggest)
            mcp_bridge_suggest
            ;;
        exec)
            mcp_bridge_exec "$@"
            ;;
        list|add|remove|configure)
            # Delega para o m√≥dulo original de gerenciamento
            load_module "mcp"
            case "$subcommand" in
                list) mcp_list_servers "." ;;
                add) mcp_add_server "." "$@" ;;
                remove) mcp_remove_server "." "$@" ;;
                configure) configure_mcp "." "$(detect_platform)" ;;
            esac
            ;;
        laravel)
            # MCP Laravel Docker - Configura√ß√£o autom√°tica de containers
            # Procura em v√°rios locais poss√≠veis (desenvolvimento ou instalado)
            local laravel_cli=""
            local possible_paths=(
                "$PWD/.aidev/mcp/laravel/bin/aidev-mcp-laravel"                    # Projeto atual
                "$HOME/projects/aidev-superpowers-v3-1/.aidev/mcp/laravel/bin/aidev-mcp-laravel"  # Dev local
                "$HOME/projects/aidev-superpowers/.aidev/mcp/laravel/bin/aidev-mcp-laravel"       # Dev alternativo
                "$AIDEV_ROOT_DIR/.aidev/mcp/laravel/bin/aidev-mcp-laravel"       # Instala√ß√£o global
            )
            
            for path in "${possible_paths[@]}"; do
                if [ -f "$path" ]; then
                    laravel_cli="$path"
                    break
                fi
            done
            
            if [ -n "$laravel_cli" ]; then
                "$laravel_cli" "$@"
            else
                print_error "MCP Laravel Docker n√£o encontrado"
                print_info "Certifique-se de que .aidev/mcp/laravel/ est√° instalado no projeto"
                print_info "Execute de dentro do diret√≥rio do projeto ou do aidev-superpowers-v3-1"
                exit 1
            fi
            ;;
        *)
            print_error "Subcomando desconhecido: $subcommand (suggest, exec, list, add, remove, laravel)"
            exit 1
            ;;
    esac
}

# ============================================================================
# Subcomando: log
# ============================================================================
# Visualiza timeline de acoes do Context Git
cmd_log() {
    local subcmd="${1:-show}"
    shift 2>/dev/null || true

    load_module "context-git" 2>/dev/null || source "$AIDEV_LIB_DIR/context-git.sh"

    case "$subcmd" in
        show)
            local limit=20
            local llm_filter=""

            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --limit) limit="$2"; shift ;;
                    --llm) llm_filter="$2"; shift ;;
                    *) ;;
                esac
                shift
            done

            print_header "AI Dev Context Log"
            ctxgit_render_timeline "$limit" "$llm_filter"
            ;;
        clear)
            rm -f "$CTXGIT_STORAGE"
            print_success "Log de contexto removido."
            ;;
        *)
            print_error "Subcomando desconhecido: $subcmd (show, clear)"
            exit 1
            ;;
    esac
}

# ============================================================================
# Subcomando: guard
# ============================================================================
# Status do alinhamento da sprint
cmd_guard() {
    local subcmd="${1:-status}"
    shift 2>/dev/null || true

    load_module "sprint-guard" 2>/dev/null || source "$AIDEV_LIB_DIR/sprint-guard.sh"
    load_module "sprint-manager" 2>/dev/null || source "$AIDEV_LIB_DIR/sprint-manager.sh"

    case "$subcmd" in
        status)
            local sprint_file=$(sprint_get_current ".")
            local task_name="Nenhuma task ativa"
            if [ -n "$sprint_file" ]; then
                task_name=$(jq -r '.tasks[] | select(.status == "in_progress") | .name' "$sprint_file" | head -n 1)
                [[ -z "$task_name" ]] && task_name="Nenhuma task em progresso"
            fi
            
            print_header "AI Dev Sprint Guard"
            echo "Tarefa Ativa: $task_name"
            guard_render_status "1.0" # Score base
            ;;
        check)
            local action="$1"
            local sprint_file=$(sprint_get_current ".")
            local task_name=""
            if [ -n "$sprint_file" ]; then
                task_name=$(jq -r '.tasks[] | select(.status == "in_progress") | .name' "$sprint_file" | head -n 1)
            fi
            
            if [ -z "$task_name" ]; then
                print_warning "Nenhuma tarefa em progresso para validar alinhamento."
                exit 0
            fi
            
            guard_check "$action" "$task_name"
            ;;
        threshold)
            local val="$1"
            if [ -n "$val" ]; then
                export GUARD_THRESHOLD="$val"
                print_success "Threshold do Sprint Guard alterado para $val (apenas nesta sess√£o)."
            else
                guard_get_threshold
            fi
            ;;
        *)
            print_error "Subcomando desconhecido: $subcmd (status, check, threshold)"
            exit 1
            ;;
    esac
}

# ============================================================================
# Subcomando: feature
# ============================================================================
cmd_feature() {
    local subcmd="${1:-status}"
    shift || true

    load_module "plans" 2>/dev/null || source "$AIDEV_LIB_DIR/plans.sh"

    case "$subcmd" in
        add)
            plans__feature_add "$@"
            ;;
        status)
            plans__feature_status "$@"
            ;;
        finish)
            plans__feature_finish "$@"
            ;;
        list)
            print_header "AI Dev - Features em Andamento"
            if ls .aidev/plans/features/*.md >/dev/null 2>&1; then
                ls -1 .aidev/plans/features/*.md 2>/dev/null | xargs -n 1 -r basename
            else
                print_info "Nenhuma funcionalidade em andamento no momento."
            fi
            ;;
        *)
            print_error "Subcomando desconhecido: $subcmd (add, finish, list)"
            exit 1
            ;;
    esac
}
cmd_triggers() {
    local subcmd="${1:-status}"
    shift || true

    load_module "triggers" 2>/dev/null || source "$AIDEV_LIB_DIR/triggers.sh"
    triggers__load || true

    case "$subcmd" in
        status)
            print_header "AI Dev - Triggers Status"
            if [ -n "$AIDEV_TRIGGERS_JSON" ]; then
                local count=$(echo "$AIDEV_TRIGGERS_JSON" | jq '.triggers | length')
                print_info "Triggers carregados: $count"
                print_info "Arquivo: .aidev/triggers/lesson-capture.yaml"
            else
                print_error "Triggers n√£o carregados."
            fi
            ;;
        list)
            print_header "AI Dev - Lista de Triggers"
            if [ -n "$AIDEV_TRIGGERS_JSON" ]; then
                echo "$AIDEV_TRIGGERS_JSON" | jq -r '.triggers[] | "[\(.enabled)] \(.id) (\(.type)) -> \(.action)"'
            else
                print_error "Nenhum trigger carregado."
            fi
            ;;
        test)
            local test_id="$1"
            if [ -z "$test_id" ]; then
                print_error "Uso: aidev triggers test <id> [contexto]"
                exit 1
            fi
            local context="${2:-contexto de teste}"
            print_info "Testando trigger: $test_id"
            echo "$AIDEV_TRIGGERS_JSON" | jq -c --arg id "$test_id" '.triggers[] | select(.id == $id)' | while read -r trigger; do
                local message=$(echo "$trigger" | jq -r '.message')
                local action=$(echo "$trigger" | jq -r '.action')
                triggers__handle_match "$test_id" "$message" "$action" "$context"
            done
            ;;
        *)
            print_error "Subcomando desconhecido: $subcmd (status, list, test)"
            exit 1
            ;;
    esac
}

# Adiciona .aidev/state ao .gitignore do projeto se existir
setup_gitignore() {
    local path="$1"
    local gitignore="$path/.gitignore"
    
    if [ -d "$path/.git" ] || [ -f "$gitignore" ]; then
        if [ ! -f "$gitignore" ]; then
            echo "# AI Dev Superpowers" > "$gitignore"
        fi
        
        if ! grep -q ".aidev/state/" "$gitignore"; then
            echo "" >> "$gitignore"
            echo "# AI Dev State (dynamic session data)" >> "$gitignore"
            echo ".aidev/state/" >> "$gitignore"
            echo ".env" >> "$gitignore"
            print_debug "Adicionado .aidev/state/ e .env ao .gitignore"
        fi
    fi
}

# Configura segredos interativamente
setup_secrets() {
    local path="$1"
    local env_file="$path/.env"
    
    # Carrega env existente se houver
    load_env "$env_file"
    
    # Context7 API Key
    if [ -z "${CONTEXT7_API_KEY:-}" ]; then
        if [ "${AIDEV_INTERACTIVE:-true}" != "true" ]; then
            print_warning "Modo n√£o-interativo: Pulando configuracao de segredos (Context7 API Key)."
            return
        fi

        print_header "Configurac√£o de Segredos"
        print_info "O MCP Context7 requer uma API Key para funcionar."
        print_info "Crie uma em: https://context7.com/dashboard"
        echo -n "üîë Cole sua Context7 API Key (ou Enter para pular): "
        read -r key
        
        if [ -n "$key" ]; then
            set_env_value "CONTEXT7_API_KEY" "$key" "$env_file"
            print_success "Chave configurada com sucesso!"
        else
            print_warning "Chave n√£o configurada. O Context7 pode n√£o funcionar."
        fi
    fi
}

# ============================================================================
# Main
# ============================================================================

# ============================================================================
# Novos Comandos Intuitivos (v3.2)
# ============================================================================


# Subcomando: new-feature
# Inicia fluxo completo de nova feature: brainstorming -> planning -> TDD
cmd_new_feature() {
    local description="${1:-}"
    shift 2>/dev/null || true
    parse_args "$@"

    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")

    if ! has_aidev_installed "$install_path"; then
        print_error "AI Dev nao esta instalado neste diretorio"
        print_info "Execute 'aidev init' primeiro"
        exit 1
    fi

    if [ -z "$description" ]; then
        print_error "Descricao da feature e obrigatoria"
        echo "Uso: aidev new-feature \"descricao da feature\""
        exit 1
    fi

    # Carrega modulo de estado unificado
    load_module "state" 2>/dev/null || source "$AIDEV_LIB_DIR/state.sh"
    load_module "orchestration" 2>/dev/null || source "$AIDEV_LIB_DIR/orchestration.sh"

    local project_name=$(detect_project_name "$install_path")
    local stack=$(detect_stack "$install_path")

    print_header "$(_ "cmd_new_feature_title")"
    echo ""
    print_info "Projeto: $project_name"
    print_info "Stack: $stack"
    print_info "Feature: $description"
    echo ""

    # Inicializa estado unificado
    export CLI_INSTALL_PATH="$install_path"
    state_init

    # Classifica intent e configura fluxo
    local intent="feature_request"
    local agents=$(orchestrator_select_agents "$intent")
    local skill=$(orchestrator_select_skill "$intent")

    # Cria checkpoint antes de iniciar
    state_checkpoint "Inicio de nova feature: $description"

    # Registra confianca inicial
    state_log_confidence "Iniciar feature: $description" "0.7" "medium"

    # Configura fluxo de skills
    state_write "active_intent" "$intent"
    state_write "intent_description" "$description"
    state_activate_skill "$skill"

    print_section "Fluxo Configurado"
    echo "  Intent:  $intent"
    echo "  Skill:   $skill"
    echo "  Agentes: $agents"
    echo ""

    print_section "Proximos Passos"
    echo "  1. Ative o modo agente na sua IA (Claude Code, Cursor, etc.)"
    echo "  2. Diga: 'modo agente' ou 'aidev'"
    echo "  3. O orquestrador ira conduzir o fluxo:"
    echo ""
    echo "     brainstorming -> writing-plans -> test-driven-development"
    echo "           |              |                    |"
    echo "     Architect        Architect          Backend/Frontend"
    echo ""
    
    # Gera prompt de ativacao
    print_section "Prompt de Ativacao (copie e cole na IA)"
    echo "----------------------------------------"
    cat << EOF
MODO AGENTE - Nova Feature

Contexto:
- Projeto: $project_name
- Stack: $stack
- Intent: $intent
- Skill inicial: $skill

Feature solicitada:
"$description"

Instrucoes:
1. Leia o arquivo .aidev/agents/orchestrator.md
2. Inicie a skill '$skill'
3. Siga o fluxo: brainstorming -> writing-plans -> test-driven-development
4. Use TDD obrigatorio: RED -> GREEN -> REFACTOR

Confirme que entendeu e inicie o brainstorming fazendo perguntas clarificadoras.
EOF
    echo "----------------------------------------"
    echo ""

    print_success "Fluxo de nova feature configurado!"
    print_info "Estado salvo em: .aidev/state/unified.json"
}

# Subcomando: fix-bug
# Inicia fluxo de correcao de bug: systematic-debugging -> learned-lesson
cmd_fix_bug() {
    local description="${1:-}"
    shift 2>/dev/null || true
    parse_args "$@"

    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")

    if ! has_aidev_installed "$install_path"; then
        print_error "AI Dev nao esta instalado neste diretorio"
        print_info "Execute 'aidev init' primeiro"
        exit 1
    fi

    if [ -z "$description" ]; then
        print_error "Descricao do bug e obrigatoria"
        echo "Uso: aidev fix-bug \"descricao do bug\""
        exit 1
    fi

    # Carrega modulos
    load_module "state" 2>/dev/null || source "$AIDEV_LIB_DIR/state.sh"
    load_module "orchestration" 2>/dev/null || source "$AIDEV_LIB_DIR/orchestration.sh"

    local project_name=$(detect_project_name "$install_path")
    local stack=$(detect_stack "$install_path")

    print_header "$(_ "cmd_fix_bug_title")"
    echo ""
    print_info "Projeto: $project_name"
    print_info "Stack: $stack"
    print_info "Bug: $description"
    echo ""

    # Inicializa estado
    export CLI_INSTALL_PATH="$install_path"
    state_init

    # Classifica intent
    local intent="bug_fix"
    local agents=$(orchestrator_select_agents "$intent")
    local skill=$(orchestrator_select_skill "$intent")

    # Cria checkpoint
    state_checkpoint "Inicio de fix bug: $description"

    # Registra confianca
    state_log_confidence "Fix bug: $description" "0.6" "medium"

    # Configura fluxo
    state_write "active_intent" "$intent"
    state_write "intent_description" "$description"
    state_activate_skill "$skill"

    print_section "Fluxo Configurado"
    echo "  Intent:  $intent"
    echo "  Skill:   $skill"
    echo "  Agentes: $agents"
    echo ""

    print_section "Metodologia de Debug"
    echo "  Phase 1: REPRODUCE - Criar teste que falha"
    echo "  Phase 2: ISOLATE   - Binary search para isolar causa"
    echo "  Phase 3: ROOT CAUSE - 5 Whys para encontrar raiz"
    echo "  Phase 4: FIX       - Corrigir e prevenir"
    echo ""

    print_section "Prompt de Ativacao (copie e cole na IA)"
    echo "----------------------------------------"
    cat << EOF
MODO AGENTE - Fix Bug

Contexto:
- Projeto: $project_name
- Stack: $stack
- Intent: $intent
- Skill: $skill

Bug reportado:
"$description"

Instrucoes:
1. Leia o arquivo .aidev/agents/orchestrator.md
2. Inicie a skill '$skill'
3. Siga as 4 fases do debugging sistematico:
   - REPRODUCE: Crie um teste que reproduza o bug
   - ISOLATE: Use binary search para isolar
   - ROOT CAUSE: Aplique 5 Whys
   - FIX: Corrija e crie teste de regressao
4. Ao final, registre a licao aprendida

Confirme que entendeu e comece pela fase REPRODUCE.
EOF
    echo "----------------------------------------"
    echo ""

    print_success "Fluxo de fix bug configurado!"
    print_info "Estado salvo em: .aidev/state/unified.json"
}

# Subcomando: suggest
# Analisa projeto e sugere proximo passo baseado em contexto
cmd_suggest() {
    parse_args "$@"

    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")

    if ! has_aidev_installed "$install_path"; then
        print_error "AI Dev nao esta instalado neste diretorio"
        print_info "Execute 'aidev init' primeiro"
        exit 1
    fi

    # Carrega modulos
    load_module "state" 2>/dev/null || source "$AIDEV_LIB_DIR/state.sh"
    load_module "orchestration" 2>/dev/null || source "$AIDEV_LIB_DIR/orchestration.sh"

    local project_name=$(detect_project_name "$install_path")
    local stack=$(detect_stack "$install_path")
    local maturity=$(detect_maturity "$install_path")

    print_header "$(_ "cmd_suggest_title")"
    echo ""

    # Inicializa estado
    export CLI_INSTALL_PATH="$install_path"
    state_init

    # Coleta informacoes do projeto
    local active_skill=$(state_get_active_skill)
    local active_agent=$(state_get_active_agent)
    local has_tests=false
    local has_failing_tests=false
    local has_uncommitted=false
    local has_prd=false

    # Verifica testes
    if [ -f "$install_path/package.json" ] || [ -f "$install_path/composer.json" ] || [ -f "$install_path/pytest.ini" ]; then
        has_tests=true
    fi

    # Verifica mudancas nao commitadas
    if [ -d "$install_path/.git" ]; then
        if [ -n "$(git -C "$install_path" status --porcelain 2>/dev/null)" ]; then
            has_uncommitted=true
        fi
    fi

    # Verifica PRD
    if [ -f "$install_path/docs/PRD.md" ] || [ -f "$install_path/PRD.md" ]; then
        has_prd=true
    fi

    print_section "Analise do Projeto"
    echo "  Projeto:     $project_name"
    echo "  Stack:       $stack"
    echo "  Maturidade:  $maturity"
    echo "  PRD:         $([ "$has_prd" = true ] && echo "Sim" || echo "Nao")"
    echo "  Testes:      $([ "$has_tests" = true ] && echo "Configurados" || echo "Nao detectados")"
    echo "  Git Status:  $([ "$has_uncommitted" = true ] && echo "Mudancas pendentes" || echo "Limpo")"
    echo ""

    # Estado atual
    print_section "Estado Atual"
    if [ -n "$active_skill" ] && [ "$active_skill" != "null" ]; then
        local progress=$(skill_get_progress "$active_skill" 2>/dev/null || echo "0/0")
        echo "  Skill Ativa: $active_skill ($progress)"
    else
        echo "  Skill Ativa: Nenhuma"
    fi
    
    if [ -n "$active_agent" ] && [ "$active_agent" != "null" ]; then
        echo "  Agente Ativo: $active_agent"
    else
        echo "  Agente Ativo: Nenhum"
    fi
    echo ""

    # Gera sugestoes
    print_section "Sugestoes"
    
    local suggestion_count=0

    # Sugestao 1: Skill pendente
    if [ -n "$active_skill" ] && [ "$active_skill" != "null" ]; then
        ((suggestion_count++)) || true
        echo "  $suggestion_count. Continuar skill '$active_skill' em andamento"
        echo "     Comando: Ative o modo agente e diga 'continuar $active_skill'"
        echo ""
    fi

    # Sugestao 2: Mudancas nao commitadas
    if [ "$has_uncommitted" = true ]; then
        ((suggestion_count++)) || true
        echo "  $suggestion_count. Commitar mudancas pendentes"
        echo "     Comando: git add . && git commit -m \"...\""
        echo ""
    fi

    # Sugestao 3: Brownfield sem testes
    if [ "$maturity" = "brownfield" ] && [ "$has_tests" = false ]; then
        ((suggestion_count++)) || true
        echo "  $suggestion_count. Adicionar testes ao projeto legado"
        echo "     Comando: aidev new-feature \"Adicionar suite de testes\""
        echo ""
    fi

    # Sugestao 4: Greenfield sem PRD
    if [ "$maturity" = "greenfield" ] && [ "$has_prd" = false ]; then
        ((suggestion_count++)) || true
        echo "  $suggestion_count. Criar documento de requisitos (PRD)"
        echo "     Acao: Crie docs/PRD.md com requisitos do projeto"
        echo ""
    fi

    # Sugestao 5: Brownfield - analisar legado
    if [ "$maturity" = "brownfield" ]; then
        ((suggestion_count++)) || true
        echo "  $suggestion_count. Rodar analise de codigo legado"
        echo "     Comando: Ative modo agente e diga 'analisar codigo legado'"
        echo ""
    fi

    # Sugestao padrao
    if [ $suggestion_count -eq 0 ]; then
        echo "  Projeto parece estar em bom estado!"
        echo ""
        echo "  Comandos disponiveis:"
        echo "    aidev new-feature \"descricao\"  - Iniciar nova feature"
        echo "    aidev fix-bug \"descricao\"      - Corrigir um bug"
        echo "    aidev status                    - Ver status detalhado"
        echo ""
    fi

    # Licoes recentes (KB)
    local kb_dir="$install_path/.aidev/memory/kb"
    if [ -d "$kb_dir" ] && [ "$(ls -A "$kb_dir" 2>/dev/null)" ]; then
        local count=$(ls "$kb_dir"/*.md 2>/dev/null | wc -l)
        print_section "Base de Conhecimento (KB)"
        echo "  üìö $count licoes disponiveis."
        echo "     Use 'aidev lessons' para consultar."
        echo ""
    fi

    print_success "Analise concluida!"
}

# Subcomando: refactor
# Inicia fluxo de refatoracao
cmd_refactor() {
    local description="${1:-}"
    shift 2>/dev/null || true
    parse_args "$@"

    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")

    if ! has_aidev_installed "$install_path"; then
        print_error "AI Dev nao esta instalado neste diretorio"
        print_info "Execute 'aidev init' primeiro"
        exit 1
    fi

    if [ -z "$description" ]; then
        print_error "Escopo da refatoracao e obrigatorio"
        echo "Uso: aidev refactor \"escopo da refatoracao\""
        exit 1
    fi

    # Carrega modulos
    load_module "state" 2>/dev/null || source "$AIDEV_LIB_DIR/state.sh"
    load_module "orchestration" 2>/dev/null || source "$AIDEV_LIB_DIR/orchestration.sh"

    local project_name=$(detect_project_name "$install_path")
    local stack=$(detect_stack "$install_path")

    print_header "AI Dev Superpowers - Refatoracao"
    echo ""
    print_info "Projeto: $project_name"
    print_info "Stack: $stack"
    print_info "Escopo: $description"
    echo ""

    # Inicializa estado
    export CLI_INSTALL_PATH="$install_path"
    state_init

    # Classifica intent
    local intent="refactor"
    local agents=$(orchestrator_select_agents "$intent")
    local skill=$(orchestrator_select_skill "$intent")

    # Cria checkpoint
    state_checkpoint "Inicio de refatoracao: $description"

    # Configura fluxo
    state_write "active_intent" "$intent"
    state_write "intent_description" "$description"
    state_activate_skill "$skill"

    print_section "Fluxo Configurado"
    echo "  Intent:  $intent"
    echo "  Skill:   $skill"
    echo "  Agentes: $agents"
    echo ""

    print_section "Prompt de Ativacao (copie e cole na IA)"
    echo "----------------------------------------"
    cat << EOF
MODO AGENTE - Refatoracao

Contexto:
- Projeto: $project_name
- Stack: $stack
- Intent: $intent
- Skill: $skill

Escopo da refatoracao:
"$description"

Instrucoes:
1. Leia o arquivo .aidev/agents/orchestrator.md
2. Execute legacy-analyzer primeiro para mapear impacto
3. Inicie a skill '$skill' para criar plano
4. Siga TDD: garanta que testes existem antes de refatorar
5. Mantenha comportamento externo identico

Confirme que entendeu e comece pela analise de impacto.
EOF
    echo "----------------------------------------"
    echo ""

    print_success "Fluxo de refatoracao configurado!"
}

# Subcomando: config
# Gerencia configuracoes do AI Dev
cmd_config() {
    local subcommand="${1:-}"
    shift 2>/dev/null || true
    
    case "$subcommand" in
        language|lang)
            cmd_config_language "$@"
            ;;
        *)
            print_error "Subcomando desconhecido: $subcommand"
            echo "Uso: aidev config [language]"
            exit 1
            ;;
    esac
}

# Subcomando: lessons
# Gerencia e consulta base de conhecimento (KB)
cmd_lessons() {
    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")
    local kb_dir="$install_path/.aidev/memory/kb"

    # Flags
    local sync_mode=false
    local search_mode=false
    local read_mode=false
    local query_term=""

    # Se o primeiro argumento for um subcomando
    case "$2" in
        --sync|sync) sync_mode=true ;;
        --search|-s|search)
            search_mode=true
            query_term="$3"
            ;;
        --read|-r|read)
            read_mode=true
            query_term="$3"
            ;;
    esac

    # Se n√£o identificou por case, tenta loop de flags
    if [ "$sync_mode" = false ] && [ "$search_mode" = false ] && [ "$read_mode" = false ]; then
        local args=("$@")
        for ((i=1; i<${#args[@]}; i++)); do
            case "${args[$i]}" in
                --sync) sync_mode=true ;;
                --search|-s) search_mode=true; query_term="${args[$((i+1))]}"; ((i++)) ;;
                --read|-r) read_mode=true; query_term="${args[$((i+1))]}"; ((i++)) ;;
            esac
        done
    fi

    print_header "AI Dev Knowledge Base (KB)"

    if [ "$sync_mode" = true ]; then
        lessons_sync
        return
    fi

    # Se nada foi solicitado, lista todos
    if [ "$search_mode" = false ] && [ "$read_mode" = false ]; then
        local files=($(ls -t "$kb_dir"/*.md 2>/dev/null))
        if [ ${#files[@]} -gt 0 ]; then
            print_section "Licoes Registradas (${#files[@]})"
            for f in "${files[@]}"; do
                echo "  üìÑ $(basename "$f")"
                head -n 2 "$f" | sed 's/^/     /'
            done
            echo ""
            print_info "Use --search ou --read para mais detalhes."
        else
            print_warning "Nenhuma licao encontrada. Use 'aidev lessons --sync' para capturar padroes."
        fi
        return
    fi

    if [ "$search_mode" = true ]; then
        print_info "Buscando por: '$query_term'..."
        local results=$(lessons_search "$query_term")
        if [ "$results" = "[]" ]; then
            print_warning "Nenhum resultado encontrado."
        else
            echo "$results" | jq -r '.[] | "üìÑ \(.title)\n   ‚îî‚îÄ \(.summary)\n"'
        fi
        return
    fi

    if [ "$read_mode" = true ]; then
        local target_file=""
        if [ -f "$kb_dir/$query_term" ]; then target_file="$kb_dir/$query_term"
        elif [ -f "$kb_dir/$query_term.md" ]; then target_file="$kb_dir/$query_term.md"
        else target_file=$(ls "$kb_dir"/*"$query_term"* 2>/dev/null | head -n 1); fi

        if [ -n "$target_file" ] && [ -f "$target_file" ]; then
            print_section "Licao: $(basename "$target_file")"
            cat "$target_file"
        else
            print_error "Licao nao encontrada: $query_term"
        fi
    fi
}

# Subcomando: config language
cmd_config_language() {
    local lang="${1:-}"
    
    if [ -z "$lang" ]; then
        print_error "Idioma obrigatorio. Uso: aidev config language [en|pt]"
        exit 1
    fi
    
    if [[ "$lang" != "en" && "$lang" != "pt" && "$lang" != "pt-BR" ]]; then
        print_error "Idioma invalido: $lang. Use 'en' ou 'pt'."
        exit 1
    fi
    
    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")
    local env_file="$install_path/.env"
    
    if [ ! -f "$env_file" ]; then
        print_error ".env nao encontrado em $install_path"
        exit 1
    fi
    
    # Atualiza .env
    set_env_value "AIDEV_LANG" "$lang" "$env_file"
    
    # Atualiza variavel atual para feedback imediato
    export AIDEV_LANG="$lang"
    set_language "$lang" 2>/dev/null || true
    
    # Re-instala agentes e regras para aplicar novo idioma
    print_step "Atualizando agentes e regras para $lang..."
    
    # Necessario carregar envVars de install_path para install_agents funcionar (CLI_PLATFORM etc)
    # Mas CLI_PLATFORM √© global. Se nao estiver setado, tentamos detectar.
    if [ -z "${CLI_PLATFORM:-}" ]; then
         CLI_PLATFORM=$(detect_platform 2>/dev/null || echo "antigravity")
    fi
    if [ -z "${CLI_STACK:-}" ]; then
         CLI_STACK=$(detect_stack "$install_path" 2>/dev/null || echo "generic")
    fi
    
    install_agents "$install_path"
    install_rules "$install_path" "$CLI_STACK"
    
    print_success "$(_ "config_lang_updated" "Idioma atualizado para: ") $lang"
}

# Subcomando: release
# Gerencia ciclo de release e versionamento
# Agora com bump automatico de versao em todos os arquivos mapeados
cmd_release() {
    # $1 pode ser o tipo de bump (major, minor, patch, current)
    local bump_type="patch"

    if [[ "$1" == "major" || "$1" == "minor" || "$1" == "patch" || "$1" == "current" ]]; then
        bump_type="$1"
        shift
    fi

    parse_args "$@"

    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")

    if ! has_aidev_installed "$install_path"; then
        print_error "AI Dev nao esta instalado neste diretorio"
        print_info "Execute 'aidev init' primeiro"
        exit 1
    fi

    # Carrega modulos necessarios
    load_module "state" 2>/dev/null || source "$AIDEV_LIB_DIR/state.sh"
    load_module "orchestration" 2>/dev/null || source "$AIDEV_LIB_DIR/orchestration.sh"
    load_module "release" 2>/dev/null || source "$AIDEV_LIB_DIR/release.sh"

    local project_name=$(detect_project_name "$install_path")
    local stack=$(detect_stack "$install_path")
    local intent="release"
    local skill="release-management"

    print_header "AI Dev - Release Manager"
    echo ""

    # === BUMP AUTOMATICO DE VERSAO ===
    # Detecta o diretorio-fonte do projeto (repositorio de desenvolvimento)
    local source_dir=""
    if [ -f "$AIDEV_ROOT_DIR/lib/release.sh" ]; then
        source_dir="$AIDEV_ROOT_DIR"
    fi

    if [ -n "$source_dir" ]; then
        print_section "Bump Automatico de Versao"
        release_execute_bump "$bump_type" "$source_dir"
        local bump_result=$?

        if [ $bump_result -ne 0 ]; then
            print_error "Falha no bump automatico. Verifique os erros acima."
            print_info "Voce pode corrigir manualmente e usar 'aidev release current' para sincronizar."
            exit 1
        fi
    else
        print_warning "Modulo release.sh nao encontrado no source. Bump manual necessario."
    fi

    # Versoes pos-bump
    local old_version="${RELEASE_OLD_VERSION:-desconhecida}"
    local new_version="${RELEASE_NEW_VERSION:-desconhecida}"

    # Define Agentes baseados no intent
    local agents=$(orchestrator_select_agents "$intent")

    # Configura fluxo no estado
    export CLI_INSTALL_PATH="$install_path"
    state_init
    state_write "active_intent" "$intent"
    state_write "intent_description" "Prepare release ($bump_type) $old_version -> $new_version"
    state_activate_skill "$skill"

    print_section "Fluxo Configurado"
    echo "  Intent:  $intent"
    echo "  Tipo:    $bump_type"
    echo "  Versao:  $old_version -> $new_version"
    echo "  Skill:   $skill"
    echo "  Agentes: $agents"
    echo ""

    print_section "Proximos Passos (para o agente IA)"
    echo "----------------------------------------"
    cat << EOF
MODO AGENTE - Release Manager

Contexto:
- Projeto: $project_name
- Stack: $stack
- Intent: $intent
- Versao: $old_version -> $new_version
- Tipo de Bump: $bump_type

Status do Bump Automatico:
- Arquivos de versao: ATUALIZADOS automaticamente
- Cache de ativacao: RECONSTRUIDO

Instrucoes (apenas o que resta):
1. Atualize o CHANGELOG.md com as mudancas desde a ultima release
2. Verifique com 'git diff' se as alteracoes estao corretas
3. Crie commit de release: chore(release): prepare v$new_version
4. Crie tag: git tag -a v$new_version -m "Release v$new_version"
5. Push (com confirmacao): git push origin main --tags

Confirme que entendeu e inicie a verificacao do CHANGELOG.
EOF
    echo "----------------------------------------"
    echo ""

    print_success "Bump automatico concluido! Falta: CHANGELOG, commit e tag."

    # Sync automatico com instalacao global apos release
    load_module "deploy-sync" 2>/dev/null || source "$AIDEV_LIB_DIR/deploy-sync.sh" 2>/dev/null || true
    if type deploy_sync_after_release &>/dev/null; then
        deploy_sync_after_release
    fi
}

# Subcomando: self-upgrade
# Atualiza a instalacao global do aidev CLI
cmd_self_upgrade() {
    parse_args "$@"

    print_header "AI Dev - Self Upgrade"

    # Detecta diretorio de instalacao global
    local global_install=""
    local source_dir=""

    # Verifica symlink do aidev
    local aidev_path
    aidev_path=$(which aidev 2>/dev/null || echo "")

    if [ -z "$aidev_path" ]; then
        print_error "aidev nao encontrado no PATH"
        exit 1
    fi

    # Resolve symlink
    if [ -L "$aidev_path" ]; then
        local real_path
        real_path=$(readlink -f "$aidev_path")
        global_install=$(dirname "$(dirname "$real_path")")
    else
        global_install=$(dirname "$(dirname "$aidev_path")")
    fi

    print_info "Instalacao global: $global_install"

    # Versao atual (l√™ diretamente do arquivo VERSION)
    local current_version
    if [ -f "$global_install/VERSION" ]; then
        current_version=$(cat "$global_install/VERSION" | tr -d '[:space:]')
    else
        current_version=$(grep "AIDEV_VERSION" "$global_install/lib/core.sh" 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+[^"]*' | head -1 || echo "desconhecida")
    fi
    print_info "Versao atual: $current_version"

    # Detecta source (projeto atual ou diretorio padrao)
    if [ -f "./lib/core.sh" ] && [ -f "./bin/aidev" ]; then
         source_dir=$(pwd)
    elif [ -f "$AIDEV_ROOT_DIR/lib/core.sh" ] && [ "$AIDEV_ROOT_DIR" != "$global_install" ]; then
         source_dir="$AIDEV_ROOT_DIR"
    elif [ -d "$HOME/projects/aidev-superpowers-v3-1" ] && [ "$HOME/projects/aidev-superpowers-v3-1" != "$global_install" ]; then
         source_dir="$HOME/projects/aidev-superpowers-v3-1"
    elif [ -d "$HOME/projects/aidev-superpowers-v3" ] && [ "$HOME/projects/aidev-superpowers-v3" != "$global_install" ]; then
         source_dir="$HOME/projects/aidev-superpowers-v3"
    elif [ -d "$HOME/aidev-superpowers" ] && [ "$HOME/aidev-superpowers" != "$global_install" ]; then
         source_dir="$HOME/aidev-superpowers"
    fi

    if [ -z "$source_dir" ] || [ ! -d "$source_dir" ]; then
        print_error "Diretorio source nao encontrado"
        print_info "Opcoes:"
        echo "  1. Clone o repositorio: git clone https://github.com/nandinhos/aidev-superpowers-v3.git"
        echo "  2. Execute de dentro do diretorio do projeto"
        exit 1
    fi

    # Versao do source (l√™ diretamente do arquivo VERSION)
    local source_version
    if [ -f "$source_dir/VERSION" ]; then
        source_version=$(cat "$source_dir/VERSION" | tr -d '[:space:]')
    else
        source_version=$(grep "AIDEV_VERSION" "$source_dir/lib/core.sh" 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+[^"]*' | head -1 || echo "desconhecida")
    fi
    print_info "Versao no source: $source_version"
    print_info "Source: $source_dir"
    echo ""

    # Verifica se precisa atualizar
    if [ "$current_version" = "$source_version" ] && [ "$AIDEV_FORCE" != true ]; then
        print_success "Ja esta na versao mais recente ($current_version)"
        exit 0
    fi

    print_step "Atualizando $current_version -> $source_version"
    echo ""

    # Dry run check
    if [ "$AIDEV_DRY_RUN" = true ]; then
        print_info "[DRY-RUN] Arquivos que seriam atualizados:"
        echo "  - bin/aidev"
        echo "  - lib/*.sh"
        echo "  - templates/"
        echo "  - tests/ (se existir)"
        echo "  - VERSION, CHANGELOG.md, README.md, install.sh"
        exit 0
    fi

    # Backup da instalacao global antes do sync
    local backup_global="${global_install}.bak.$(date +%s)"
    print_step "Criando backup da instalacao global..."
    cp -r "$global_install" "$backup_global" 2>/dev/null || {
        print_warning "Nao foi possivel criar backup em: $backup_global"
    }

    # Executa sync
    # Funcao de rollback em caso de falha
    _self_upgrade_rollback() {
        if [ -d "$backup_global" ]; then
            print_warning "Executando rollback..."
            rm -rf "$global_install"
            mv "$backup_global" "$global_install"
            print_info "Rollback concluido. Versao restaurada: $current_version"
        fi
    }

    print_step "Sincronizando bin/..."
    rsync -a --delete "$source_dir/bin/" "$global_install/bin/" 2>/dev/null || {
        print_error "Falha ao sincronizar bin/"
        _self_upgrade_rollback
        exit 1
    }

    print_step "Sincronizando lib/..."
    rsync -a --delete "$source_dir/lib/" "$global_install/lib/" 2>/dev/null || {
        print_error "Falha ao sincronizar lib/"
        _self_upgrade_rollback
        exit 1
    }

    print_step "Sincronizando templates/..."
    rsync -a --delete "$source_dir/templates/" "$global_install/templates/" 2>/dev/null || {
        print_error "Falha ao sincronizar templates/"
        _self_upgrade_rollback
        exit 1
    }

    # Sincroniza tests se existir
    if [ -d "$source_dir/tests" ]; then
        print_step "Sincronizando tests/..."
        rsync -a --delete "$source_dir/tests/" "$global_install/tests/" 2>/dev/null || true
    fi

    # Sincroniza arquivos raiz essenciais
    print_step "Sincronizando arquivos raiz..."
    for root_file in VERSION CHANGELOG.md README.md install.sh MANIFEST.json; do
        if [ -f "$source_dir/$root_file" ]; then
            cp -f "$source_dir/$root_file" "$global_install/$root_file" 2>/dev/null || true
        fi
    done

    echo ""
    print_success "Atualizado com sucesso: $current_version -> $source_version"

    # Verifica a nova versao
    local new_version
    new_version=$("$global_install/bin/aidev" --version 2>/dev/null | sed -E 's/aidev v//' || echo "")
    if [ -n "$new_version" ]; then
        print_info "Verificado: aidev v$new_version"
    fi

    # Limpar backup apos sucesso (manter apenas ultimo)
    if [ -d "$backup_global" ]; then
        print_info "Backup da versao anterior salvo em: $backup_global"
    fi
}

# Subcomando: restore
# Restaura checkpoints de sessao anteriores
# ============================================================================
# HANDOFF - Handoff cognitivo entre sessoes LLM (Sprint 5 - Feature 5.1)
# ============================================================================
cmd_handoff() {
    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")

    if ! has_aidev_installed "$install_path"; then
        print_error "AI Dev nao esta instalado neste diretorio"
        exit 1
    fi

    # Carrega modulos
    load_module "context-monitor" 2>/dev/null || source "$install_path/lib/context-monitor.sh" 2>/dev/null || true
    load_module "checkpoint-manager" 2>/dev/null || source "$install_path/lib/checkpoint-manager.sh" 2>/dev/null || true

    local subcmd="${1:-help}"
    shift 2>/dev/null || true

    case "$subcmd" in
        create)
            # Parse argumentos nomeados
            local cot="" hypothesis="" mental_model="" observations=""
            while [ $# -gt 0 ]; do
                case "$1" in
                    --cot) cot="$2"; shift 2 ;;
                    --hypothesis) hypothesis="$2"; shift 2 ;;
                    --mental-model) mental_model="$2"; shift 2 ;;
                    --observations) observations="$2"; shift 2 ;;
                    *) shift ;;
                esac
            done

            # Cria checkpoint com contexto cognitivo
            local ckpt_id
            ckpt_id=$(ckpt_create "$install_path" "handoff" "Handoff cognitivo entre sessoes" \
                "$cot" "$hypothesis" "$mental_model" "$observations")

            echo ""
            echo "============================================================"
            echo "  Handoff criado com sucesso"
            echo "============================================================"
            echo ""
            echo "  Checkpoint: $ckpt_id"
            [ -n "$cot" ] && echo "  Raciocinio: $cot"
            [ -n "$hypothesis" ] && echo "  Hipotese: $hypothesis"
            [ -n "$mental_model" ] && echo "  Modelo Mental: $mental_model"
            [ -n "$observations" ] && echo "  Observacoes: $observations"
            echo ""
            echo "  Para retomar: aidev handoff resume"
            echo "============================================================"
            ;;

        resume)
            local latest_id=""
            if type ckpt_get_latest &>/dev/null; then
                latest_id=$(ckpt_get_latest "$install_path")
            fi

            if [ -z "$latest_id" ]; then
                print_info "Nenhum handoff encontrado"
                echo "Use 'aidev handoff create --cot \"seu raciocinio\"' para criar um handoff"
                return 0
            fi

            local ckpt_file="$install_path/.aidev/state/sprints/current/checkpoints/${latest_id}.json"

            echo ""
            echo "============================================================"
            echo "  RETOMAR HANDOFF - $latest_id"
            echo "============================================================"
            echo ""

            if type ckpt_generate_restore_prompt &>/dev/null; then
                ckpt_generate_restore_prompt "$ckpt_file"
            else
                echo "Arquivo: $ckpt_file"
                echo "INSTRUCAO: Retome o trabalho a partir deste checkpoint."
            fi
            ;;

        status)
            local ckpt_dir="$install_path/.aidev/state/sprints/current/checkpoints"

            if [ ! -d "$ckpt_dir" ]; then
                print_info "Nenhum handoff disponivel"
                return 0
            fi

            local files
            files=$(ls -t "$ckpt_dir"/ckpt-*.json 2>/dev/null) || true

            if [ -z "$files" ]; then
                print_info "Nenhum handoff disponivel"
                return 0
            fi

            local latest
            latest=$(echo "$files" | head -1)

            echo ""
            echo "============================================================"
            echo "  Handoff Status"
            echo "============================================================"
            echo ""

            if [ -f "$latest" ] && command -v jq >/dev/null 2>&1; then
                local ckpt_id=$(jq -r '.checkpoint_id // "unknown"' "$latest")
                local trigger=$(jq -r '.trigger // "unknown"' "$latest")
                local created=$(jq -r '.created_at // "unknown"' "$latest")
                local desc=$(jq -r '.description // ""' "$latest")
                local cot=$(jq -r '.cognitive_context.chain_of_thought // ""' "$latest")
                local total
                total=$(echo "$files" | wc -l)

                echo "  Ultimo: $ckpt_id"
                echo "  Criado: $created"
                echo "  Trigger: $trigger"
                echo "  Descricao: $desc"
                [ -n "$cot" ] && echo "  Raciocinio: $cot"
                echo ""
                echo "  Total de checkpoints: $total"
            else
                echo "  $(basename "$latest" .json)"
            fi
            echo ""
            echo "============================================================"
            ;;

        help|"")
            echo ""
            echo "Uso: aidev handoff <subcomando> [opcoes]"
            echo ""
            echo "Subcomandos:"
            echo "  create     Cria um handoff cognitivo"
            echo "  resume     Retoma o ultimo handoff"
            echo "  status     Mostra status dos handoffs"
            echo ""
            echo "Opcoes (create):"
            echo "  --cot <texto>          Chain of thought (raciocinio)"
            echo "  --hypothesis <texto>   Hipotese ativa"
            echo "  --mental-model <texto> Modelo mental do fluxo"
            echo "  --observations <texto> Observacoes livres"
            echo ""
            echo "Exemplos:"
            echo "  aidev handoff create --cot \"Implementando validadores\""
            echo "  aidev handoff resume"
            echo "  aidev handoff status"
            ;;

        *)
            print_error "Subcomando desconhecido: $subcmd"
            echo "Use 'aidev handoff help' para ver opcoes"
            ;;
    esac
}

# ============================================================================
# FALLBACK - Gerar artefatos de fallback para LLMs sem MCP (Sprint 5 - Feature 5.3)
# ============================================================================
cmd_fallback() {
    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")

    if ! has_aidev_installed "$install_path"; then
        print_error "AI Dev nao esta instalado neste diretorio"
        exit 1
    fi

    # Carrega modulos
    load_module "context-monitor" 2>/dev/null || source "$install_path/lib/context-monitor.sh" 2>/dev/null || true
    load_module "checkpoint-manager" 2>/dev/null || source "$install_path/lib/checkpoint-manager.sh" 2>/dev/null || true
    load_module "fallback-generator" 2>/dev/null || source "$install_path/lib/fallback-generator.sh" 2>/dev/null || true

    local subcmd="${1:-help}"
    shift 2>/dev/null || true

    local fallback_dir="$install_path/.aidev/state/fallback"

    case "$subcmd" in
        generate)
            # Busca o checkpoint mais recente
            local latest_id=""
            if type ckpt_get_latest &>/dev/null; then
                latest_id=$(ckpt_get_latest "$install_path")
            fi

            local ckpt_file=""
            if [ -n "$latest_id" ]; then
                ckpt_file="$install_path/.aidev/state/sprints/current/checkpoints/${latest_id}.json"
            fi

            if type fallback_generate_all &>/dev/null; then
                fallback_generate_all "$install_path" "$ckpt_file"
            else
                print_error "Modulo fallback-generator nao disponivel"
                return 1
            fi
            ;;

        show)
            if [ ! -d "$fallback_dir" ]; then
                print_info "Nenhum artefato de fallback encontrado"
                echo "Use 'aidev fallback generate' para gerar"
                return 0
            fi

            local files
            files=$(ls "$fallback_dir"/*.md 2>/dev/null) || true

            if [ -z "$files" ]; then
                print_info "Nenhum artefato de fallback encontrado"
                echo "Use 'aidev fallback generate' para gerar"
                return 0
            fi

            echo ""
            echo "============================================================"
            echo "  Artefatos de Fallback"
            echo "============================================================"
            echo ""

            for f in $files; do
                local fname
                fname=$(basename "$f")
                local size
                size=$(wc -c < "$f" 2>/dev/null || echo 0)
                local modified
                modified=$(stat -c %y "$f" 2>/dev/null | cut -d'.' -f1 || echo "unknown")
                echo "  $fname ($size bytes) - $modified"
            done

            echo ""
            echo "  Diretorio: $fallback_dir"
            echo "============================================================"
            ;;

        clean)
            if [ -d "$fallback_dir" ]; then
                rm -f "$fallback_dir"/*.md 2>/dev/null
                print_success "Artefatos de fallback removidos"
            else
                print_info "Nenhum artefato para limpar"
            fi
            ;;

        help|"")
            echo ""
            echo "Uso: aidev fallback <subcomando>"
            echo ""
            echo "Subcomandos:"
            echo "  generate   Gera artefatos de fallback em Markdown"
            echo "  show       Mostra artefatos existentes"
            echo "  clean      Remove artefatos de fallback"
            echo ""
            echo "Artefatos gerados em .aidev/state/fallback/:"
            echo "  last-checkpoint.md       Checkpoint legivel"
            echo "  sprint-context.md        Sprint status formatado"
            echo "  active-files.md          Arquivos em trabalho"
            echo "  reconstruction-guide.md  Guia de retomada"
            echo ""
            echo "Exemplos:"
            echo "  aidev fallback generate"
            echo "  aidev fallback show"
            echo "  aidev fallback clean"
            ;;

        *)
            print_error "Subcomando desconhecido: $subcmd"
            echo "Use 'aidev fallback help' para ver opcoes"
            ;;
    esac
}

cmd_restore() {
    # Nao faz shift aqui - main() ja removeu o comando 'restore'
    # Nao chama parse_args para preservar subcomandos como --latest
    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")

    if ! has_aidev_installed "$install_path"; then
        print_error "AI Dev nao esta instalado neste diretorio"
        exit 1
    fi

    # Carrega modulos
    load_module "context-monitor" 2>/dev/null || source "$install_path/lib/context-monitor.sh" 2>/dev/null || true
    load_module "checkpoint-manager" 2>/dev/null || source "$install_path/lib/checkpoint-manager.sh" 2>/dev/null || true

    local subcmd="${1:-list}"

    case "$subcmd" in
        --list|list)
            print_header "Checkpoints Disponiveis"
            local ckpt_dir="$install_path/.aidev/state/sprints/current/checkpoints"
            
            if [ ! -d "$ckpt_dir" ]; then
                print_info "Nenhum checkpoint encontrado"
                return 0
            fi
            
            # Get checkpoint files sorted by time (newest first)
            local files
            files=$(ls -t "$ckpt_dir"/ckpt-*.json 2>/dev/null) || true

            if [ -z "$files" ]; then
                print_info "Nenhum checkpoint encontrado"
                return 0
            fi

            local count=0
            # Use while read to handle filenames with spaces
            echo "$files" | while IFS= read -r f; do
                [ -f "$f" ] || continue
                
                if command -v jq >/dev/null 2>&1; then
                    local ckpt_id trigger desc created
                    ckpt_id=$(jq -r '.checkpoint_id // "unknown"' "$f" 2>/dev/null) || ckpt_id="unknown"
                    trigger=$(jq -r '.trigger // "unknown"' "$f" 2>/dev/null) || trigger="unknown"
                    desc=$(jq -r '.description // ""' "$f" 2>/dev/null) || desc=""
                    created=$(jq -r '.created_at // "unknown"' "$f" 2>/dev/null) || created="unknown"
                    echo "  [$((count+1))] $ckpt_id"
                    echo "      Trigger: $trigger | $created"
                    echo "      $desc"
                    echo ""
                else
                    # Fallback without jq
                    echo "  [$((count+1))] $(basename "$f" .json)"
                    echo ""
                fi
                count=$((count + 1))
            done
            
            # Count total
            local total
            total=$(echo "$files" | wc -l)
            echo "Total: $total checkpoints"
            ;;

        --latest|latest)
            print_header "Restaurar Ultimo Checkpoint"
            
            local latest_id=""
            if type ckpt_get_latest &>/dev/null; then
                latest_id=$(ckpt_get_latest "$install_path")
            else
                # Fallback implementation
                local ckpt_dir="$install_path/.aidev/state/sprints/current/checkpoints"
                if [ -d "$ckpt_dir" ]; then
                    local latest_file
                    latest_file=$(ls -t "$ckpt_dir"/ckpt-*.json 2>/dev/null | head -1) || true
                    if [ -n "$latest_file" ]; then
                        latest_id=$(basename "$latest_file" .json)
                    fi
                fi
            fi

            if [ -z "$latest_id" ]; then
                print_error "Nenhum checkpoint encontrado"
            else
                local ckpt_file="$install_path/.aidev/state/sprints/current/checkpoints/${latest_id}.json"
                
                # Gera prompt de restauracao
                echo ""
                echo "============================================================"
                echo "  RESTAURAR CONTEXTO - Checkpoint: $latest_id"
                echo "============================================================"
                echo ""
                if type ckpt_generate_restore_prompt &>/dev/null; then
                    ckpt_generate_restore_prompt "$ckpt_file"
                else
                    # Fallback simple output
                    echo "Arquivo: $ckpt_file"
                    echo ""
                    echo "INSTRUCAO: Retome o trabalho a partir deste checkpoint."
                    echo "============================================================"
                fi
            fi
            ;;

        *)
            # Tenta restaurar por ID especifico
            local ckpt_id="$subcmd"
            local ckpt_file="$install_path/.aidev/state/sprints/current/checkpoints/${ckpt_id}.json"

            if [ ! -f "$ckpt_file" ]; then
                print_error "Checkpoint nao encontrado: $ckpt_id"
                echo ""
                echo "Use 'aidev restore --list' para ver checkpoints disponiveis"
                return 1
            fi

            print_header "Restaurar Checkpoint: $ckpt_id"
            
            if type ckpt_generate_restore_prompt &>/dev/null; then
                ckpt_generate_restore_prompt "$ckpt_file"
            else
                # Fallback simple output
                echo ""
                echo "============================================================"
                echo "  RESTAURAR CONTEXTO - Checkpoint: $ckpt_id"
                echo "============================================================"
                echo ""
                echo "Arquivo: $ckpt_file"
                echo ""
                echo "INSTRUCAO: Retome o trabalho a partir deste checkpoint."
                echo "============================================================"
            fi
            ;;
    esac
}

# Subcomando: error-recovery
# Gerencia recupera√ß√£o autom√°tica de erros (Sprint 6.2)
cmd_error_recovery() {
    load_module "error-recovery"
    error_recovery_cli "$@"
}

# Subcomando: patch
# Aplica patches de corre√ß√£o ao sistema
cmd_patch() {
    local patch_type="${1:-plans}"
    
    case "$patch_type" in
        plans)
            print_header "AI Dev - Patch de Estrutura de Planos"
            print_info "Aplicando corre√ß√£o para estrutura de planos..."
            
            local templates_dir="$AIDEV_ROOT_DIR/templates/plans"
            local dirs=("backlog" "features" "current" "history" "archive")
            
            # Cria diret√≥rios se n√£o existirem
            for dir in "${dirs[@]}"; do
                if [ ! -d "$templates_dir/$dir" ]; then
                    ensure_dir "$templates_dir/$dir"
                    print_success "Criado: templates/plans/$dir/"
                fi
            done
            
            # Verifica templates README
            local readme_templates=(
                "README.md"
                "backlog/README.md"
                "features/README.md"
                "current/README.md"
                "history/README.md"
                "archive/README.md"
            )
            
            local missing=0
            for template in "${readme_templates[@]}"; do
                if [ ! -f "$templates_dir/$template.tmpl" ]; then
                    print_warning "Template n√£o encontrado: $template.tmpl"
                    missing=$((missing + 1))
                fi
            done
            
            if [ $missing -eq 0 ]; then
                print_success "Todos os templates de planos est√£o presentes!"
                print_info "A estrutura ser√° aplicada automaticamente em novos projetos."
                print_info "Para aplicar em projetos existentes, use: aidev upgrade"
            else
                print_error "Faltam $missing templates. Execute: aidev system sync"
                return 1
            fi
            ;;
        *)
            echo "Uso: aidev patch [plans]"
            echo ""
            echo "Patches dispon√≠veis:"
            echo "  plans    Verifica e aplica estrutura de planos"
            echo ""
            return 1
            ;;
    esac
}

# Subcomando: feature
# Gerencia ciclo de vida de features (list, complete, status)
main() {
    local command="${1:-help}"
    shift || true

    case "$command" in
        init)
            cmd_init "$@"
            ;;
        config)
            cmd_config "$@"
            ;;
        mcp)
            cmd_mcp "$@"
            ;;
        upgrade)
            cmd_upgrade "$@"
            ;;
        add-skill)
            cmd_add_skill "$@"
            ;;
        add-rule)
            cmd_add_rule "$@"
            ;;
        add-agent)
            cmd_add_agent "$@"
            ;;
        status)
            cmd_status "$@"
            ;;
        doctor)
            cmd_doctor "$@"
            ;;
        snapshot)
            cmd_snapshot "$@"
            ;;
        agent)
            cmd_agent "$@"
            ;;
        commit|c)
            source "$AIDEV_LIB_DIR/workflow-commit.sh"
            cmd_commit "$@"
            ;;
        cp)
            source "$AIDEV_LIB_DIR/workflow-commit.sh"
            cmd_commit_push "$@"
            ;;
        sync)
            source "$AIDEV_LIB_DIR/workflow-sync.sh"
            sync_workflow "$@"
            ;;
        validate)
            source "$AIDEV_LIB_DIR/workflow-sync.sh"
            validate_conformity
            ;;
        cache)
            cmd_cache "$@"
            ;;
        start)
            cmd_start "$@"
            ;;
        metrics)
            cmd_metrics "$@"
            ;;
        triggers)
            cmd_triggers "$@"
            ;;
        integrity)
            cmd_doctor "$@"
            ;;
        new-feature)
            cmd_new_feature "$@"
            ;;
        fix-bug)
            cmd_fix_bug "$@"
            ;;
        suggest)
            cmd_suggest "$@"
            ;;
        lessons)
            cmd_lessons "$@"
            ;;
        refactor)
            cmd_refactor "$@"
            ;;
        release)
            cmd_release "$@"
            ;;
        log)
            cmd_log "$@"
            ;;
        guard)
            cmd_guard "$@"
            ;;
        roadmap)
            cmd_roadmap "$@"
            ;;
        system)
            cmd_system "$@"
            ;;
        feature)
            cmd_feature "$@"
            ;;
        error-recovery)
            cmd_error_recovery "$@"
            ;;
        version)
            load_module "version-check"
            version_check_cli "$@"
            ;;
        self-upgrade)
            cmd_self_upgrade "$@"
            ;;
        restore)
            cmd_restore "$@"
            ;;
        handoff)
            cmd_handoff "$@"
            ;;
        fallback)
            cmd_fallback "$@"
            ;;
        patch)
            cmd_patch "$@"
            ;;
        -h|--help|help)
            show_help
            ;;
        -v|--version|version)
            show_version
            ;;
        *)
            print_error "Comando desconhecido: $command"
            echo ""
            echo "Use 'aidev --help' para ver comandos dispon√≠veis"
            exit 1
            ;;
    esac
}

# Executa
main "$@"
