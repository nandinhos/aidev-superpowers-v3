#!/bin/bash

# ============================================================================
# AI Dev Superpowers V3 - CLI Principal
# ============================================================================
# Comando unificado 'aidev' para gest√£o de projetos com AI
# 
# Uso: aidev <comando> [op√ß√µes]
# ============================================================================

set -eEo pipefail

# Handler de erro para Auto-Cura (Fase 4)
error_handler() {
    local exit_code=$?
    local line_no=$1
    
    # Ignora erros se j√° estivermos dentro do doctor para evitar loop infinito
    if [[ "${BASH_COMMAND:-}" == *"doctor"* ]]; then
        return
    fi

    echo ""
    echo "‚ùå $(_ "error_ops") (Erro: $exit_code na linha $line_no)"
    echo "üîç $(_ "suggest_doctor")"
    echo ""
}

trap 'error_handler $LINENO' ERR

# Detecta diret√≥rio do script (resolve symlinks)
SOURCE="${BASH_SOURCE[0]}"
while [ -L "$SOURCE" ]; do
    DIR="$(cd -P "$(dirname "$SOURCE")" && pwd)"
    SOURCE="$(readlink "$SOURCE")"
    [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
done
AIDEV_BIN_DIR="$(cd -P "$(dirname "$SOURCE")" && pwd)"
AIDEV_ROOT_DIR="$(dirname "$AIDEV_BIN_DIR")"
AIDEV_LIB_DIR="$AIDEV_ROOT_DIR/lib"

# Carrega m√≥dulos essenciais
source "$AIDEV_LIB_DIR/loader.sh"
load_essential_modules
load_module "templates"
load_module "mcp"

# Tenta carregar ambiente (idioma, segredos)
load_env 2>/dev/null || true

# ============================================================================
# Subcomandos
# ============================================================================

# Subcomando: init
# Inicializa AI Dev em um projeto
cmd_init() {
    parse_args "$@"
    
    if ! validate_args; then
        exit 1
    fi
    # Diret√≥rio de instala√ß√£o
    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")

    # Sele√ß√£o de Idioma Interativa
    if [ "${AIDEV_INTERACTIVE:-true}" = "true" ] && [ "${CLI_LANGUAGE_SET:-false}" = "false" ]; then
        echo -n "$(_ "select_lang")"
        read -r selected_lang
        case "$selected_lang" in
            en|EN) CLI_LANGUAGE="en" ;;
            pt|PT|pt-BR|PT-BR) CLI_LANGUAGE="pt-BR" ;;
            *) CLI_LANGUAGE="pt-BR" ;; # Default
        esac
    fi
    set_language "${CLI_LANGUAGE:-pt-BR}"

    print_header "AI Dev Superpowers"
    print_mode "$CLI_MODE" "$(_ "init_header") $install_path"
    
    # Auto-detec√ß√£o de stack
    if [ "$CLI_AUTO_DETECT" = "true" ]; then
        CLI_STACK=$(detect_stack "$install_path")
        print_info "Stack detectada: $CLI_STACK"
    fi
    
    # Auto-detec√ß√£o de plataforma
    if [ "$CLI_PLATFORM" = "auto" ]; then
        CLI_PLATFORM=$(detect_platform)
        print_info "Plataforma detectada: $CLI_PLATFORM"
    fi

    # Auto-detec√ß√£o de Maturidade e Estilo (Smart Context)
    local maturity=$(detect_maturity "$install_path")
    local style=$(detect_style "$install_path")
    print_info "Contexto: $maturity | Estilo: ${style:-none}"

    # Valida√ß√£o de Greenfield (PRD)
    export CONTEXT_INSTRUCTIONS=""

    if [ "$maturity" = "greenfield" ]; then
        if [ ! -f "$install_path/docs/PRD.md" ] && [ ! -f "$install_path/PRD.md" ]; then
             print_warning "Greenfield detectado: PRD ausente!"
             echo "   ‚Ñπ  Recomendado criar 'docs/PRD.md' para que o Agente Architect possa"
             echo "      analisar requisitos e criar skills personalizadas."
        fi
        CONTEXT_INSTRUCTIONS=$(cat <<EOF
## Modo: Greenfield (Novo Projeto)
- **Foco Prim√°rio**: Setup e Arquitetura.
- **Regra de Ouro**: Siga o PRD (\`docs/PRD.md\`) como a unica fonte da verdade.
- **Workflow**: 
    1. Architect deve criar skills personalizadas baseadas no PRD.
    2. Validar se o ERD (Diagrama de Entidade-Relacionamento) existe.
    3. Definir padr√µes de c√≥digo para o projeto desde o dia 1.
EOF
)
    elif [ "$maturity" = "brownfield" ]; then
         print_info "Brownfield detectado: Sugerimos rodar 'legacy-analyzer' para diagn√≥stico."
         CONTEXT_INSTRUCTIONS=$(cat <<EOF
## Modo: Brownfield (Projeto Legado e Em Andamento)
- **Foco Prim√°rio**: Estabilidade e Manutenibilidade.
- **Regra de Ouro**: "First, do no harm". Analise antes de alterar.
- **Workflow**:
    1. Antes de iniciar feature nova, execute \`legacy-analyzer\` para mapa de impacto.
    2. Respeite os padr√µes de estilo encontrados (verifique \`.eslintrc\`, \`pint.json\`, etc).
    3. Use a skill \`learned-lesson\` frequentemente para documentar armadilhas do legado.
EOF
)
    fi
    export CONTEXT_INSTRUCTIONS
    
    # Mostra configura√ß√£o
    if [ "${AIDEV_DEBUG:-false}" = "true" ]; then
        show_config_summary
    fi
    
    # Dry run apenas mostra o que seria feito
    if [ "$AIDEV_DRY_RUN" = "true" ]; then
        print_info "[DRY-RUN] Simulando instala√ß√£o..."
    fi
    
    # Reseta contadores
    reset_counters
    
    # Cria estrutura base
    print_step "$(_ "step_structure")"
    create_base_structure "$install_path"
    
    # Instala agentes
    print_step "$(_ "step_agents")"
    install_agents "$install_path"
    
    # Instala skills
    print_step "$(_ "step_skills")"
    install_skills "$install_path"
    
    # Instala rules
    print_step "$(_ "step_rules")"
    install_rules "$install_path" "$CLI_STACK"
    
    # Configura segredos PRIMEIRO (antes do MCP para ter API Keys dispon√≠veis)
    if [ "$CLI_NO_MCP" != "true" ]; then
        print_step "$(_ "step_secrets")"
        setup_secrets "$install_path"

        # Carrega as vari√°veis do .env para usar na configura√ß√£o MCP
        load_env "$install_path/.env"
    fi

    # Configura MCP (agora com API Keys j√° definidas)
    if [ "$CLI_NO_MCP" != "true" ]; then
        print_step "$(_ "step_mcp")"
        configure_mcp "$install_path" "$CLI_PLATFORM"
    fi

    # Instala instru√ß√µes de ativa√ß√£o para a plataforma
    print_step "$(_ "step_platform")"
    install_platform_instructions "$install_path" "$CLI_PLATFORM"

    # Configura gitignore
    print_step "$(_ "step_gitignore")"
    setup_gitignore "$install_path"

    # Persiste estado inicial
    export CLI_INSTALL_PATH="$install_path"
    set_state_value "current_fase" "3"
    set_state_value "current_sprint" "4"
    set_state_value "current_platform" "$CLI_PLATFORM"
    set_state_value "current_stack" "$CLI_STACK"
    set_state_value "language" "$CLI_LANGUAGE"
    set_state_value "maturity" "$maturity"
    set_state_value "style" "$style"
    set_state_value "initialized_at" "$(date -Iseconds)"

    # Sum√°rio final
    print_summary "$CLI_MODE" "$CLI_STACK"
    
    print_success "$(_ "init_success")"
}

# Subcomando: upgrade
# Atualiza instala√ß√£o existente
cmd_upgrade() {
    parse_args "$@"

    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")

    if ! has_aidev_installed "$install_path"; then
        print_error "AI Dev n√£o est√° instalado neste diret√≥rio"
        print_info "Use 'aidev init' para instalar"
        exit 1
    fi

    print_header "AI Dev Superpowers"
    print_mode "upgrade" "Atualizando em $install_path"

    # Detecta stack e plataforma
    CLI_STACK=$(detect_stack "$install_path")
    local platform="${CLI_PLATFORM:-auto}"
    if [ "$platform" = "auto" ]; then
        platform=$(detect_platform)
    fi
    print_info "Stack: $CLI_STACK | Plataforma: $platform"

    # Backup antes de atualizar
    print_step "Criando backup..."
    local backup_dir="$install_path/.aidev/backups/$(date +%Y%m%d%H%M%S)"
    ensure_dir "$backup_dir"
    cp -r "$install_path/.aidev/agents" "$backup_dir/" 2>/dev/null || true
    cp -r "$install_path/.aidev/skills" "$backup_dir/" 2>/dev/null || true

    reset_counters
    AIDEV_FORCE=true

    # Garante estrutura base (novos diret√≥rios)
    create_base_structure "$install_path"

    # Reinstala componentes
    print_step "Atualizando agentes..."
    install_agents "$install_path"

    print_step "Atualizando skills..."
    install_skills "$install_path"

    # Atualiza instru√ß√µes de plataforma
    print_step "Atualizando instru√ß√µes de plataforma..."
    install_platform_instructions "$install_path" "$platform"

    print_summary "upgrade" "$CLI_STACK"
    print_success "Atualiza√ß√£o conclu√≠da!"
    print_info "Backup salvo em: $backup_dir"
}

# Subcomando: add-skill
# Adiciona skill customizada
cmd_add_skill() {
    local skill_name="${1:-}"
    shift || true
    parse_args "$@"
    
    if [ -z "$skill_name" ]; then
        print_error "Nome da skill √© obrigat√≥rio"
        echo "Uso: aidev add-skill <nome>"
        exit 1
    fi
    
    local install_path="${CLI_INSTALL_PATH:-.}"
    local skill_dir="$install_path/.aidev/skills/$skill_name"
    
    if [ -d "$skill_dir" ] && [ "$AIDEV_FORCE" != "true" ]; then
        print_warning "Skill '$skill_name' j√° existe (use --force)"
        exit 1
    fi
    
    print_step "Criando skill '$skill_name'..."
    
    ensure_dir "$skill_dir"
    
    # Cria SKILL.md template
    cat > "$skill_dir/SKILL.md" << EOF
---
name: $skill_name
description: Descri√ß√£o da skill $skill_name
triggers:
  - "trigger1"
  - "trigger2"
globs:
  - "**/*.md"
---

# $skill_name Skill

## When to Use
[Descreva quando usar esta skill]

## Purpose
[Descreva o prop√≥sito]

## Process
1. [Passo 1]
2. [Passo 2]
3. [Passo 3]

## Key Principles
- [Princ√≠pio 1]
- [Princ√≠pio 2]
EOF
    
    print_success "Skill '$skill_name' criada em $skill_dir"
    print_info "Edite o arquivo SKILL.md para customizar"
}

# Subcomando: add-rule
# Adiciona regra customizada
cmd_add_rule() {
    local rule_name="${1:-}"
    shift || true
    parse_args "$@"
    
    if [ -z "$rule_name" ]; then
        print_error "Nome da rule √© obrigat√≥rio"
        echo "Uso: aidev add-rule <nome>"
        exit 1
    fi
    
    local install_path="${CLI_INSTALL_PATH:-.}"
    local rule_file="$install_path/.aidev/rules/${rule_name}.md"
    
    if [ -f "$rule_file" ] && [ "$AIDEV_FORCE" != "true" ]; then
        print_warning "Rule '$rule_name' j√° existe (use --force)"
        exit 1
    fi
    
    print_step "Criando rule '$rule_name'..."
    
    ensure_dir "$(dirname "$rule_file")"
    
    cat > "$rule_file" << EOF
# $rule_name Rules

## Conventions
[Descreva as conven√ß√µes]

## Patterns
[Descreva os patterns a seguir]

## Anti-Patterns
[Descreva o que evitar]

## Examples
\`\`\`
// Exemplo de c√≥digo
\`\`\`
EOF
    
    print_success "Rule '$rule_name' criada: $rule_file"
}

# Subcomando: add-agent
# Adiciona agente customizado
cmd_add_agent() {
    local agent_name="${1:-}"
    shift || true
    parse_args "$@"
    
    if [ -z "$agent_name" ]; then
        print_error "Nome do agente √© obrigat√≥rio"
        echo "Uso: aidev add-agent <nome>"
        exit 1
    fi
    
    local install_path="${CLI_INSTALL_PATH:-.}"
    local agent_file="$install_path/.aidev/agents/${agent_name}.md"
    
    if [ -f "$agent_file" ] && [ "$AIDEV_FORCE" != "true" ]; then
        print_warning "Agent '$agent_name' j√° existe (use --force)"
        exit 1
    fi
    
    print_step "Criando agent '$agent_name'..."
    
    ensure_dir "$(dirname "$agent_file")"
    
    cat > "$agent_file" << EOF
# $agent_name Agent

## Role
[Descreva o papel deste agente]

## Responsibilities
- [Responsabilidade 1]
- [Responsabilidade 2]
- [Responsabilidade 3]

## Guidelines
- [Guideline 1]
- [Guideline 2]

## Tools
- [Tool 1]
- [Tool 2]
EOF
    
    print_success "Agent '$agent_name' criado: $agent_file"
}

# Subcomando: status
# Mostra status da instala√ß√£o
cmd_status() {
    parse_args "$@"
    
    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")
    
    print_header "AI Dev Superpowers"
    
    if ! has_aidev_installed "$install_path"; then
        print_warning "AI Dev n√£o est√° instalado neste diret√≥rio"
        exit 0
    fi
    
    print_success "AI Dev instalado: $install_path/.aidev/"
    
    # Detecta contexto
    local stack=$(detect_stack "$install_path")
    local platform=$(detect_platform)
    local project_name=$(detect_project_name "$install_path")
    local runtime=$(detect_runtime)
    
    print_section "Contexto"
    echo "  Projeto:    $project_name"
    echo "  Stack:      $stack"
    echo "  Plataforma: $platform"
    echo "  Runtime:    $runtime"
    
    # Progresso da Sess√£o (L√™ do estado unificado)
    local unified_state_file="$install_path/.aidev/state/unified.json"
    local active_intent="N/A"
    local intent_desc="N/A"
    local active_skill="N/A"
    local last_checkpoint="N/A"

    if [ -f "$unified_state_file" ] && command -v jq >/dev/null 2>&1; then
        active_intent=$(jq -r '.active_intent // "N/A"' "$unified_state_file")
        intent_desc=$(jq -r '.intent_description // "N/A"' "$unified_state_file")
        active_skill=$(jq -r '.active_skill // "N/A"' "$unified_state_file")
        last_checkpoint=$(jq -r '.rollback_stack[0].description // "N/A"' "$unified_state_file")
    fi

    # Exibe dashboard din√¢mico
    print_section "Progresso (Em Tempo Real)"
    echo "  Intent:     $active_intent"
    echo "  Descri√ß√£o:  $intent_desc"
    echo "  Skill:      $active_skill"
    echo "  Checkout:   $last_checkpoint"
    echo "  Fase/Sprint: ${current_fase:-3} / ${current_sprint:-4}"
    
    # Hist√≥rico Git Recente
    if [ -d "$install_path/.git" ]; then
        print_section "Hist√≥rico Recente (Git)"
        git -C "$install_path" log -n 3 --oneline | sed 's/^/  /'
    fi
    
    # Lista agentes
    print_section "Agentes Instalados"
    local agents_dir="$install_path/.aidev/agents"
    if [ -d "$agents_dir" ]; then
        local count=0
        for agent in "$agents_dir"/*.md; do
            if [ -f "$agent" ]; then
                echo "  ‚Ä¢ $(basename "$agent" .md)"
                ((count++)) || true
            fi
        done
        echo "  Total: $count agentes"
    else
        echo "  Nenhum agente instalado"
    fi
    
    # Lista skills
    print_section "Skills Instaladas"
    local skills_dir="$install_path/.aidev/skills"
    if [ -d "$skills_dir" ]; then
        local count=0
        for skill in "$skills_dir"/*/SKILL.md; do
            if [ -f "$skill" ]; then
                local skill_name=$(dirname "$skill")
                echo "  ‚Ä¢ $(basename "$skill_name")"
                ((count++)) || true
            fi
        done
        echo "  Total: $count skills"
    else
        echo "  Nenhuma skill instalada"
    fi
    
    # Lista rules
    print_section "Rules Instaladas"
    local rules_dir="$install_path/.aidev/rules"
    if [ -d "$rules_dir" ]; then
        local count=0
        for rule in "$rules_dir"/*.md; do
            if [ -f "$rule" ]; then
                echo "  ‚Ä¢ $(basename "$rule" .md)"
                ((count++)) || true
            fi
        done
        echo "  Total: $count rules"
    else
        echo "  Nenhuma rule instalada"
    fi
    
    echo ""
}

# Subcomando: snapshot
# Gera um resumo do contexto atual para migra√ß√£o entre IAs
cmd_snapshot() {
    parse_args "$@"
    
    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")
    
    if ! has_aidev_installed "$install_path"; then
        print_error "AI Dev n√£o est√° instalado neste diret√≥rio"
        exit 1
    fi

    print_header "AI Dev Snapshot (Context Passport)"
    print_info "Gerando resumo t√©cnico para migra√ß√£o de modelo..."
    echo ""

    # Coleta dados
    local fase=$(get_state_value "current_fase" "1")
    local sprint=$(get_state_value "current_sprint" "0")
    local task=$(get_state_value "current_task" "Pendente")
    local project_name=$(detect_project_name "$install_path")
    local stack=$(detect_stack "$install_path")
    local platform=$(detect_platform)

    # In√≠cio do bloco de snapshot
    echo "--- SNAPSHOT START ---"
    echo "Crie um novo chat de IA e cole o conte√∫do abaixo:"
    echo "------------------------------------------------"
    echo ""
    echo "# üõ∞Ô∏è AI DEV CONTEXT SNAPSHOT: $project_name"
    echo ""
    echo "## üìç Estado Operacional"
    echo "- **Fase**: $fase"
    echo "- **Sprint**: $sprint"
    echo "- **Tarefa Atual**: $task"
    echo "- **Stack**: $stack"
    echo "- **Origem**: $platform"
    echo ""

    echo "## üìú Hist√≥rico Recente (Git)"
    if [ -d "$install_path/.git" ]; then
        git log -n 5 --oneline | sed 's/^/- /'
    else
        echo "- (Git n√£o dispon√≠vel ou n√£o inicializado)"
    fi
    echo ""

    echo "## üìã Decis√µes e Planos Ativos"
    local plans=""
    [ -f "$install_path/implementation_plan.md" ] && plans="$plans- ./implementation_plan.md\n"
    [ -d "$install_path/docs/plans" ] && plans="$plans$(ls "$install_path/docs/plans"/*.md 2>/dev/null | sed "s|$install_path/||" | sed 's/^/- /')\n"
    
    if [ -n "$plans" ]; then
        echo -e "$plans"
    else
        echo "- Nenhum plano de implementa√ß√£o detectado."
    fi
    echo ""

    echo "## üß† Base de Conhecimento (KB)"
    local kb_dir="$install_path/.aidev/memory/kb"
    if [ -d "$kb_dir" ]; then
        shopt -s nullglob
        local kb_files=("$kb_dir"/*.md)
        shopt -u nullglob
        local kb_count=${#kb_files[@]}
        
        if [ "$kb_count" -gt 0 ]; then
            echo "- $kb_count li√ß√µes dispon√≠veis em .aidev/memory/kb/"
            echo "- Use a tool \`read_file\` se precisar de contexto espec√≠fico."
            # Lista as 3 mais recentes (precisa de ls -t pois glob nao garante ordem por data)
            ls -t "$kb_dir"/*.md 2>/dev/null | head -n 3 | sed 's/^/- /'
        else
            echo "- Nenhuma li√ß√£o registrada."
        fi
    else
        echo "- Nenhuma li√ß√£o registrada."
    fi
    echo ""

    # Estado Unificado
    local unified_state_file="$install_path/.aidev/state/unified.json"
    if [ -f "$unified_state_file" ]; then
        echo "## ‚ö° Estado T√©cnico Unificado (Session State)"
        echo "\`\`\`json"
        if command -v jq >/dev/null 2>&1; then
            # Otimizacao de Tokens: Mantem apenas os ultimos 5 checkpoints de rollback
            jq '.rollback_stack |= (if length > 5 then .[-5:] else . end)' "$unified_state_file"
        else
            cat "$unified_state_file"
        fi
        echo "\`\`\`"
        echo ""
    fi

    echo "## üöÄ Instru√ß√µes para o Pr√≥ximo Modelo"
    echo "1. Analise o estado atual, mas **AGUARDE** o comando do usu√°rio."
    echo "2. Carregue o **Estado T√©cnico Unificado** acima na sua mem√≥ria de trabalho."
    echo "3. O projeto usa o framework AI Dev Superpowers V3."
    echo "4. O √∫ltimo status conhecido foi: **$task**."
    echo "5. N√£o execute nenhuma a√ß√£o aut√¥noma at√© que o usu√°rio solicite."
    echo ""
    echo "------------------------------------------------"
    echo "--- SNAPSHOT END ---"
    echo ""

    print_success "Snapshot gerado com sucesso! Copie o bloco acima."
}

# Subcomando: agent
# Gera prompt de ativacao do modo agente para colar na IA
cmd_agent() {
    parse_args "$@"

    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")

    if ! has_aidev_installed "$install_path"; then
        print_error "AI Dev nao esta instalado neste diretorio"
        print_info "Execute 'aidev init' primeiro"
        exit 1
    fi

    # Coleta dados do projeto
    local project_name=$(detect_project_name "$install_path")
    local stack=$(detect_stack "$install_path")
    local platform=$(detect_platform)
    local fase=$(get_state_value "current_fase" "1")
    local sprint=$(get_state_value "current_sprint" "0")

    # Conta agentes e skills
    local agent_count=0
    local skill_count=0
    if [ -d "$install_path/.aidev/agents" ]; then
        agent_count=$(ls "$install_path/.aidev/agents"/*.md 2>/dev/null | wc -l)
    fi
    if [ -d "$install_path/.aidev/skills" ]; then
        skill_count=$(ls -d "$install_path/.aidev/skills"/*/ 2>/dev/null | wc -l)
    fi

    print_header "AI Dev Agent Mode"
    print_info "Gerando prompt de ativacao..."
    echo ""

    # Verifica se existe cache e carrega
    load_module "cache"
    local cache_content=""
    if validate_cache_freshness "$install_path"; then
        cache_content=$(get_cached_activation "$install_path")
    fi

    # Carrega estado da sess√£o (Continuity Context)
    local session_context=""
    local unified_file="$install_path/.aidev/state/unified.json"
    local active_intent=""
    local active_skill=""
    local last_activity=""
    
    if [ -f "$unified_file" ] && command -v jq >/dev/null 2>&1; then
        active_intent=$(jq -r '.active_intent // empty' "$unified_file")
        active_skill=$(jq -r '.active_skill // empty' "$unified_file")
        last_activity=$(jq -r '.session.last_activity // empty' "$unified_file")
        
        if [ -n "$active_intent" ] || [ -n "$active_skill" ]; then
            session_context="
CONTEXTO ATUAL (SESSAO ANTERIOR):
- Intencao Ativa: ${active_intent:-Nenhum}
- Skill em Uso: ${active_skill:-Nenhuma}
- Ultima Atividade: $last_activity

ATENCAO: VOCE DEVE CONTINUAR O TRABALHO ACIMA SE AINDA NAO ESTIVER CONCLUIDO.
NAO SUGIRA 'legacy-analyzer' OU NOVAS TAREFAS SE HOUVER UMA INTENCAO ATIVA.
"
        fi
    fi

    # Gera o prompt
    echo "============================================================"
    echo "COPIE E COLE O TEXTO ABAIXO NA SUA IA:"
    echo "============================================================"
    echo ""
    cat << EOF
ATIVAR MODO AGENTE - AI Dev Superpowers

Voce esta em um projeto com AI Dev Superpowers v3 instalado.

PROJETO: $project_name
STACK: $stack
FASE: $fase | SPRINT: $sprint
AGENTES: $agent_count especializados
SKILLS: $skill_count automatizadas
$session_context
EOF

    if [ -n "$cache_content" ]; then
        echo "CACHE DE ATIVACAO DETECTADO E CARREGADO NO CONTEXTO:"
        echo "\`\`\`json"
        echo "$cache_content"
        echo "\`\`\`"
        echo ""
        echo "INSTRUCOES DE ATIVACAO (OTIMIZADAS):"
        echo "1. Use o CACHE acima como fonte de verdade sobre Agentes, Skills e Stack."
        echo "2. NAO leia arquivos individuais em .aidev/agents/ ou .aidev/skills/ a menos que precise de detalhes profundos."
        echo "3. O arquivo .aidev/agents/orchestrator.md continua sendo seu cerebro de coordenacao."
    else
        echo "INSTRUCOES DE ATIVACAO:"
        echo "1. Leia o arquivo .aidev/agents/orchestrator.md - este e seu cerebro de coordenacao"
        echo "2. Voce tem acesso a $agent_count agentes especializados em .aidev/agents/"
        echo "3. Voce tem acesso a $skill_count skills automatizadas em .aidev/skills/"
        echo "4. Siga as regras da stack em .aidev/rules/$stack.md"
    fi

    cat << EOF

PRINCIPIOS INEGOCIAVEIS:
- TDD OBRIGATORIO: Sempre escreva teste ANTES do codigo (RED -> GREEN -> REFACTOR)
- YAGNI: So implemente o que foi solicitado
- Commits atomicos com mensagens descritivas

FLUXO DE TRABALHO:
- Para novas features: brainstorming -> writing-plans -> test-driven-development -> code-review
- Para bugs: systematic-debugging -> learned-lesson
- Para refatoracao: writing-plans -> test-driven-development -> code-review

EOF

    # Se cache N√ÉO existe, lista agentes e skills individualmente
    if [ -z "$cache_content" ]; then
        cat << EOF

AGENTES DISPONIVEIS:
EOF

        # Lista agentes
        if [ -d "$install_path/.aidev/agents" ]; then
            for agent in "$install_path/.aidev/agents"/*.md; do
                if [ -f "$agent" ]; then
                    local name=$(basename "$agent" .md)
                    echo "- $name"
                fi
            done
        fi

        cat << EOF

SKILLS DISPONIVEIS:
EOF

        # Lista skills
        if [ -d "$install_path/.aidev/skills" ]; then
            for skill_dir in "$install_path/.aidev/skills"/*/; do
                if [ -d "$skill_dir" ]; then
                    local name=$(basename "$skill_dir")
                    echo "- $name"
                fi
            done
        fi
    fi

    cat << EOF

Confirme que voce entendeu e esta pronto para operar como orquestrador.
Responda: "Modo Agente ativado. Pronto para orquestrar."
EOF

    echo ""
    echo "============================================================"
    echo ""
    print_success "Prompt gerado! Cole na sua IA para ativar o modo agente."
    echo ""
    print_info "Dica: Use 'aidev agent | pbcopy' (macOS) ou 'aidev agent | xclip' (Linux) para copiar automaticamente"
}

# Subcomando: cache
# Gerencia cache de ativa√ß√£o para economia de tokens
cmd_cache() {
    # N√£o usa parse_args pois --build/--clear s√£o espec√≠ficos deste subcomando
    local install_path="."
    local action="status"
    
    # Parse manual de argumentos
    for arg in "$@"; do
        case "$arg" in
            cache) ;; # ignora o pr√≥prio nome do comando
            --build|-b) action="build" ;;
            --clear|-c) action="clear" ;;
            --show|-s) action="show" ;;
            --install-in) ;; # handled next
            *)
                # Se o anterior foi --install-in, este √© o path
                if [[ "${prev_arg:-}" == "--install-in" ]]; then
                    install_path="$arg"
                fi
                ;;
        esac
        prev_arg="$arg"
    done

    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")

    if ! has_aidev_installed "$install_path"; then
        print_error "AI Dev n√£o est√° instalado neste diret√≥rio"
        print_info "Execute 'aidev init' primeiro"
        exit 1
    fi

    # Carrega m√≥dulo de cache
    load_module "cache"

    print_header "AI Dev Cache Manager"

    case "$action" in
        build)
            print_step "Construindo cache de ativa√ß√£o..."
            save_activation_cache "$install_path"
            print_success "Cache constru√≠do com sucesso!"
            show_cache_status "$install_path"
            ;;
        clear)
            print_step "Limpando cache..."
            invalidate_cache "$install_path"
            print_success "Cache removido!"
            ;;
        show)
            print_step "Conte√∫do do cache:"
            local cache_file="$install_path/$CACHE_DIR/$CACHE_FILE"
            if [ -f "$cache_file" ]; then
                cat "$cache_file"
            else
                print_warning "Cache n√£o existe. Use 'aidev cache --build' para criar."
            fi
            ;;
        status|*)
            show_cache_status "$install_path"
            print_info "Op√ß√µes:"
            echo "  --build, -b   Constr√≥i/atualiza o cache"
            echo "  --clear, -c   Remove o cache"
            echo "  --show, -s    Exibe conte√∫do do cache (JSON)"
            ;;
    esac
}

# Subcomando: start
# Inicia sessao interativa do modo agente (exibe instrucoes de ativacao)
cmd_start() {
    parse_args "$@"

    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")

    if ! has_aidev_installed "$install_path"; then
        print_error "AI Dev nao esta instalado neste diretorio"
        print_info "Execute 'aidev init' primeiro"
        exit 1
    fi

    local project_name=$(detect_project_name "$install_path")
    local stack=$(detect_stack "$install_path")
    local platform=$(detect_platform)

    print_header "AI Dev Superpowers - Modo Agente"
    echo ""
    print_success "Projeto: $project_name"
    print_info "Stack: $stack | Plataforma: $platform"
    echo ""

    print_section "Como Ativar o Modo Agente"
    echo ""
    echo "  Opcao 1: Diga para sua IA:"
    echo "    ${CYAN}\"modo agente\"${NC} ou ${CYAN}\"aidev\"${NC} ou ${CYAN}\"superpowers\"${NC}"
    echo ""
    echo "  Opcao 2: Gere um prompt completo:"
    echo "    ${CYAN}aidev agent${NC}"
    echo ""
    echo "  Opcao 3: Cole o prompt diretamente:"
    echo "    ${CYAN}aidev agent | pbcopy${NC}  (macOS)"
    echo "    ${CYAN}aidev agent | xclip -selection clipboard${NC}  (Linux)"
    echo ""

    print_section "Agentes Disponiveis"
    if [ -d "$install_path/.aidev/agents" ]; then
        for agent in "$install_path/.aidev/agents"/*.md; do
            if [ -f "$agent" ]; then
                echo "  - $(basename "$agent" .md)"
            fi
        done
    fi
    echo ""

    print_section "Skills Disponiveis"
    if [ -d "$install_path/.aidev/skills" ]; then
        for skill_dir in "$install_path/.aidev/skills"/*/; do
            if [ -d "$skill_dir" ]; then
                echo "  - $(basename "$skill_dir")"
            fi
        done
    fi
    echo ""

    print_section "Proximos Passos"
    echo "  1. Abra sua IA (Claude Code, Cursor, etc.)"
    echo "  2. Diga 'modo agente' ou use 'aidev agent'"
    echo "  3. O orquestrador assumira o controle"
    echo ""
}

# Subcomando: metrics
# Exibe dashboard de telemetria
cmd_metrics() {
    parse_args "$@"
    
    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")
    local metrics_file="$install_path/.aidev/state/metrics.log"
    
    print_header "AI Dev Telemetry & Metrics"
    
    if [ ! -f "$metrics_file" ]; then
        print_warning "Nenhuma m√©trica coletada ainda."
        exit 0
    fi
    
    print_info "Fonte: $metrics_file"
    echo ""
    
    # Verifica depend√™ncia jq
    if ! command -v jq >/dev/null 2>&1; then
        print_error "jq √© necess√°rio para visualizar m√©tricas."
        exit 1
    fi
    
    print_section "Resumo de Skills"
    # Agrega por nome de skill: count, avg duration, success count
    cat "$metrics_file" | jq -r 'select(.type=="skill_execution")' | \
    jq -s 'group_by(.name) | .[] | {
        name: .[0].name, 
        count: length, 
        avg_duration: (map(.duration)|add/length|floor), 
        success: (map(select(.status=="completed"))|length),
        failed: (map(select(.status=="failed"))|length)
    }' | \
    jq -r '"  ‚Ä¢ \(.name): \(.count) execu√ß√µes | M√©dia: \(.avg_duration)ms | ‚úì \(.success) | ‚úó \(.failed)"'
    
    echo ""
    print_section "Atividade de Agentes"
    # Agrega por agente
    cat "$metrics_file" | jq -r 'select(.type=="agent_activate")' | \
    jq -s 'group_by(.name) | .[] | {name: .[0].name, count: length}' | \
    jq -r '"  ‚Ä¢ \(.name): \(.count) ativa√ß√µes"'
    
    echo ""
    print_success "Dashboard atualizado."
}

# Subcomando: doctor
# Diagn√≥stico da instala√ß√£o e ambiente com sugest√µes de reparo
cmd_doctor() {
    local fix_mode=false
    local filtered_args=()
    
    for arg in "$@"; do
        if [ "$arg" == "--fix" ]; then
            fix_mode=true
        else
            filtered_args+=("$arg")
        fi
    done

    # Parse remaining args
    parse_args "${filtered_args[@]}"
    
    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")
    
    print_header "AI Dev Doctor"
    
    local issues=0
    local warnings=0

    # 1. Depend√™ncias do Sistema (Core)
    print_section "Dependencias do Sistema"
    local deps=("git" "jq" "bash" "sed" "grep")
    for dep in "${deps[@]}"; do
        if command -v "$dep" >/dev/null 2>&1; then
            print_success "$dep: $(command -v "$dep")"
        else
            if [ "$dep" == "jq" ]; then
                print_warning "$dep: NAO ENCONTRADO (usando fallback Bash)"
                ((warnings++)) || true
            else
                print_error "$dep: NAO ENCONTRADO"
                ((issues++)) || true
            fi
        fi
    done

    # 1.1 Depend√™ncias MCP (para servidores MCP funcionarem)
    print_section "Dependencias MCP"

    # Node.js / npx (para Context7)
    if command -v node >/dev/null 2>&1; then
        local node_version=$(node --version 2>/dev/null)
        print_success "node: $node_version"
        if command -v npx >/dev/null 2>&1; then
            print_success "npx: $(command -v npx)"
        else
            print_warning "npx: NAO ENCONTRADO (Context7 MCP nao funcionara)"
            ((warnings++)) || true
        fi
    else
        print_warning "node: NAO ENCONTRADO (Context7 MCP nao funcionara)"
        ((warnings++)) || true
    fi

    # Python / uvx (para Serena e basic-memory)
    if command -v python3 >/dev/null 2>&1; then
        local python_version=$(python3 --version 2>/dev/null)
        print_success "python3: $python_version"
    else
        print_warning "python3: NAO ENCONTRADO"
        ((warnings++)) || true
    fi

    if command -v uvx >/dev/null 2>&1; then
        print_success "uvx: $(command -v uvx)"
    elif command -v uv >/dev/null 2>&1; then
        print_success "uv: $(command -v uv) (uvx disponivel via 'uv tool run')"
    else
        print_warning "uvx/uv: NAO ENCONTRADO (Serena e basic-memory MCP nao funcionarao)"
        print_info "Instale com: curl -LsSf https://astral.sh/uv/install.sh | sh"
        ((warnings++)) || true
    fi
    
    # 2. Verifica instala√ß√£o
    print_section "Verificando Instala√ß√£o"
    if has_aidev_installed "$install_path"; then
        print_success ".aidev/ existe"
        
        # Verifica diret√≥rios
        local dirs=("agents" "skills" "rules" "state" "memory/kb")
        for dir in "${dirs[@]}"; do
            if [ -d "$install_path/.aidev/$dir" ]; then
                print_success ".aidev/$dir/ existe"
            else
                if [ "$fix_mode" = "true" ]; then
                    print_info "$(_ "fix_recreating_dir") .aidev/$dir/"
                    ensure_dir "$install_path/.aidev/$dir"
                    print_success ".aidev/$dir/ $(_ "fix_created")"
                else
                    print_warning ".aidev/$dir/ n√£o encontrado"
                    ((warnings++)) || true
                fi
            fi
        done
    else
        print_error ".aidev/ n√£o encontrado em $install_path"
        if [ "$fix_mode" = "true" ]; then
            print_info "$(_ "fix_restoring_base")"
            create_base_structure "$install_path"
            print_success "$(_ "fix_restored")"
        else
            ((issues++)) || true
        fi
    fi
    
    # 3. Estado da Sess√£o
    print_section "Estado da Sess√£o"
    local state_file="$install_path/.aidev/state/session.json"
    if [ -f "$state_file" ]; then
        if command -v jq >/dev/null 2>&1 && ! jq . "$state_file" >/dev/null 2>&1; then
            print_error "Arquivo session.json corrompido"
            ((issues++)) || true
        else
            print_success "Arquivo session.json √≠ntegro"
        fi
    else
        print_info "session.json ainda n√£o inicializado"
    fi
    
    # 4. Segredos e Seguran√ßa
    print_section "Segredos e Seguranca"
    local env_file="$install_path/.env"
    if [ -f "$env_file" ]; then
        load_env "$env_file"
        if [ -n "${CONTEXT7_API_KEY:-}" ]; then
            print_success "Context7 API Key configurada"
        else
            print_warning "Context7 API Key ausente no .env"
            ((warnings++)) || true
        fi
        
        # Verifica se .env est√° no gitignore
        if [ -f "$install_path/.gitignore" ]; then
            if grep -q "^\.env" "$install_path/.gitignore" || grep -q "/\.env" "$install_path/.gitignore"; then
                print_success ".env protegido no .gitignore"
            else
                if [ "$fix_mode" = "true" ]; then
                    print_info "$(_ "fix_protecting_env")"
                    echo ".env" >> "$install_path/.gitignore"
                    print_success "$(_ "fix_protected_env")"
                else
                    print_error ".env N√ÉO est√° no .gitignore (RISCO DE EXPOSI√á√ÉO)"
                    ((issues++)) || true
                fi
            fi
        fi
    else
        print_info ".env nao encontrado (opcional, mas recomendado para MCP)"
    fi

    # 4.1 Verificacao de sincronizacao MCP
    print_section "Sincronizacao MCP"
    local mcp_file="$install_path/.mcp.json"
    if [ -f "$mcp_file" ]; then
        if command -v jq >/dev/null 2>&1; then
            local mcp_key=$(jq -r '.mcpServers.context7.env.CONTEXT7_API_KEY // empty' "$mcp_file" 2>/dev/null)
            local env_key="${CONTEXT7_API_KEY:-}"

            if [ -n "$env_key" ] && [ -n "$mcp_key" ]; then
                if [ "$env_key" = "$mcp_key" ]; then
                    print_success ".mcp.json sincronizado com .env"
                else
                    print_warning ".mcp.json desatualizado (API Key diferente do .env)"
                    if [ "$fix_mode" = "true" ]; then
                        print_info "Regenerando .mcp.json..."
                        AIDEV_FORCE=true
                        configure_mcp "$install_path" "$(detect_platform)"
                        print_success ".mcp.json atualizado!"
                    else
                        print_info "Execute 'aidev doctor --fix' para sincronizar"
                    fi
                    ((warnings++)) || true
                fi
            elif [ -n "$env_key" ] && [ -z "$mcp_key" ]; then
                print_warning ".mcp.json nao tem API Key configurada"
                if [ "$fix_mode" = "true" ]; then
                    print_info "Regenerando .mcp.json..."
                    AIDEV_FORCE=true
                    configure_mcp "$install_path" "$(detect_platform)"
                    print_success ".mcp.json atualizado!"
                fi
                ((warnings++)) || true
            elif [ -z "$env_key" ]; then
                print_info "API Key nao configurada (Context7 pode nao funcionar)"
            fi
        else
            print_info ".mcp.json existe (jq nao disponivel para validar sincronizacao)"
        fi
    else
        print_info ".mcp.json nao encontrado"
    fi

    # 5. Contexto
    print_section "Contexto Detectado"
    local platform=$(detect_platform)
    local stack=$(detect_stack "$install_path")
    print_info "Plataforma: $platform"
    print_info "Stack:      $stack"

    # 6. Verifica√ß√£o de Integridade Cr√≠tica
    print_section "Integridade do Sistema"
    local critical_dirs=(".aidev/agents" ".aidev/skills" ".aidev/rules" "bin")
    for dir in "${critical_dirs[@]}"; do
        if [ -d "$install_path/$dir" ]; then
            print_success "Diret√≥rio vital ok: $dir"
        else
            print_error "DIRET√ìRIO VITAL AUSENTE: $dir"
            ((issues++)) || true
        fi
    done

    # 5. Sugest√µes de Reparo
    if [ $issues -gt 0 ] || [ $warnings -gt 0 ]; then
        print_section "Sugest√µes de Reparo"
        if ! command -v jq >/dev/null 2>&1; then
            echo -e "  ‚Ä¢ ${YELLOW}Instalar jq:${NC} sudo apt install jq  (ou brew install jq)"
        fi
        if ! command -v git >/dev/null 2>&1; then
            echo -e "  ‚Ä¢ ${RED}Instalar git:${NC} sudo apt install git"
        fi
        if [ ! -d "$install_path/.aidev" ]; then
            echo -e "  ‚Ä¢ ${CYAN}Inicializar Projeto:${NC} aidev init"
        fi
        if [ -f "$install_path/.env" ] && [ -z "${CONTEXT7_API_KEY:-}" ]; then
            echo -e "  ‚Ä¢ ${YELLOW}Context7:${NC} Adicione CONTEXT7_API_KEY ao seu arquivo .env"
        fi
    fi

    echo ""
    if [ $issues -eq 0 ]; then
        if [ $warnings -eq 0 ]; then
            print_success "Tudo limpo! Seu ambiente est√° saud√°vel."
        else
            print_info "Ambiente operacional, mas com $warnings avisos."
        fi
    else
        print_error "Encontrados $issues problemas cr√≠ticos. Verifique as mensagens acima."
    fi
    echo ""
}

# ============================================================================
# Fun√ß√µes de Instala√ß√£o
# ============================================================================

# Cria estrutura base de diret√≥rios
create_base_structure() {
    local path="$1"
    
    ensure_dir "$path/.aidev"
    ensure_dir "$path/.aidev/agents"
    ensure_dir "$path/.aidev/skills"
    ensure_dir "$path/.aidev/rules"
    ensure_dir "$path/.aidev/state"
    ensure_dir "$path/.aidev/memory/kb"
    ensure_dir "$path/.aidev/analysis"
}

# Instala agentes a partir dos templates com suporte a overrides por plataforma
# Instala agentes a partir dos templates com suporte a overrides por plataforma
install_agents() {
    local path="$1"
    local agents_dir="$path/.aidev/agents"
    local lang_suffix=$(get_lang_suffix 2>/dev/null || echo "pt")
    
    # Define diret√≥rios de origem baseados no idioma
    local base_templates_dir="$AIDEV_ROOT_DIR/templates/agents/$lang_suffix"
    # Fallback para root
    if [ ! -d "$base_templates_dir" ]; then
        base_templates_dir="$AIDEV_ROOT_DIR/templates/agents"
    fi
    
    local platform_templates_dir="$AIDEV_ROOT_DIR/templates/platform/$CLI_PLATFORM/agents/$lang_suffix"
    # Fallback para root da plataforma
    if [ ! -d "$platform_templates_dir" ]; then
        platform_templates_dir="$AIDEV_ROOT_DIR/templates/platform/$CLI_PLATFORM/agents"
    fi
    
    # Exporta vari√°veis para os templates
    export PROJECT_NAME=$(detect_project_name "$path")
    export STACK="$CLI_STACK"
    export PLATFORM="$CLI_PLATFORM"
    
    # Itera sobre os templates base (se existirem)
    if [ -d "$base_templates_dir" ]; then
        for template in "$base_templates_dir"/*.md.tmpl; do
            if [ -f "$template" ]; then
                process_agent_template "$template" "$agents_dir" "$platform_templates_dir"
            fi
        done
    fi
    
    # Se usou fallback base, itera sobre ele tambem (caso n√£o tenha iterado acima)
    if [ "$base_templates_dir" == "$AIDEV_ROOT_DIR/templates/agents" ]; then
         for template in "$base_templates_dir"/*.md.tmpl; do
            if [ -f "$template" ]; then
                process_agent_template "$template" "$agents_dir" "$platform_templates_dir"
            fi
        done
    fi
    
    # Hack para iterar sobre plataforma se existirem agentes EXCLUSIVOS da plataforma
    if [ -d "$platform_templates_dir" ]; then
         for template in "$platform_templates_dir"/*.md.tmpl; do
            if [ -f "$template" ]; then
                local name=$(basename "$template" .md.tmpl)
                if [ ! -f "$agents_dir/${name}.md" ]; then
                    process_agent_template "$template" "$agents_dir" "$platform_templates_dir"
                fi
            fi
        done
    fi
}

process_agent_template() {
    local template="$1"
    local output_dir="$2"
    local platform_dir="$3"
    
    local name=$(basename "$template" .md.tmpl)
    local output="$output_dir/${name}.md"
    
    # Verifica override
    local template_to_use="$template"
    if [ -n "$CLI_PLATFORM" ] && [ -f "$platform_dir/${name}.md.tmpl" ]; then
        template_to_use="$platform_dir/${name}.md.tmpl"
        print_debug "Usando override de plataforma para: $name"
    fi
    
    if should_write_file "$output"; then
        process_template "$template_to_use" "$output"
        print_debug "Instalado: $name"
    fi
}

# Instala skills a partir dos templates
install_skills() {
    local path="$1"
    local skills_dir="$path/.aidev/skills"
    
    for skill_template_dir in "$AIDEV_ROOT_DIR/templates/skills"/*/; do
        if [ -d "$skill_template_dir" ]; then
            local skill_name=$(basename "$skill_template_dir")
            local output_dir="$skills_dir/$skill_name"
            
            ensure_dir "$output_dir"
            
            for template in "$skill_template_dir"/*.tmpl; do
                if [ -f "$template" ]; then
                    local name=$(basename "$template" .tmpl)
                    local output="$output_dir/$name"
                    
                    if should_write_file "$output"; then
                        process_template "$template" "$output"
                    fi
                fi
            done
        fi
    done
}

# Instala rules a partir dos templates
install_rules() {
    local path="$1"
    local stack="$2"
    local rules_dir="$path/.aidev/rules"
    local lang_suffix=$(get_lang_suffix 2>/dev/null || echo "pt")
    
    # Busca templates localizados (ex: templates/rules/pt/generic.md.tmpl)
    # Tenta: localized -> legacy/root
    
    local generic_template="$AIDEV_ROOT_DIR/templates/rules/$lang_suffix/generic.md.tmpl"
    if [ ! -f "$generic_template" ]; then
        generic_template="$AIDEV_ROOT_DIR/templates/rules/generic.md.tmpl"
    fi

    if [ -f "$generic_template" ]; then
        process_template "$generic_template" "$rules_dir/generic.md"
    fi
    
    # Instala rule espec√≠fica da stack
    local stack_template="$AIDEV_ROOT_DIR/templates/rules/$lang_suffix/${stack}.md.tmpl"
    if [ ! -f "$stack_template" ]; then
        stack_template="$AIDEV_ROOT_DIR/templates/rules/${stack}.md.tmpl"
    fi
    
    if [ -f "$stack_template" ]; then
        process_template "$stack_template" "$rules_dir/${stack}.md"
    fi
}

# Configura MCP
configure_mcp() {
    local path="$1"
    local platform="$2"

    # Carrega m√≥dulo MCP se n√£o carregado
    load_module "mcp" 2>/dev/null || true

    # Setup completo do MCP Engine
    setup_mcp_engine "$path" "$platform"
}

# Instala instru√ß√µes de plataforma (lembrete de ativa√ß√£o)
install_platform_instructions() {
    local path="$1"
    local platform="$2"

    # Exporta vari√°veis para templates
    export PROJECT_NAME=$(detect_project_name "$path")
    export STACK="$CLI_STACK"

    local templates_dir="$AIDEV_ROOT_DIR/templates/platform"

    # Sempre instala o arquivo gen√©rico AI_INSTRUCTIONS.md em .aidev/
    local generic_template="$templates_dir/AI_INSTRUCTIONS.md.tmpl"
    if [ -f "$generic_template" ]; then
        local output="$path/.aidev/AI_INSTRUCTIONS.md"
        if should_write_file "$output"; then
            process_template "$generic_template" "$output"
            print_debug "Instru√ß√µes gen√©ricas: AI_INSTRUCTIONS.md"
        fi
    fi

    # Sempre instala o QUICKSTART.md consolidado em .aidev/
    local quickstart_template="$templates_dir/QUICKSTART.md.tmpl"
    if [ -f "$quickstart_template" ]; then
        local output="$path/.aidev/QUICKSTART.md"
        if should_write_file "$output"; then
            process_template "$quickstart_template" "$output"
            print_success "Criado: .aidev/QUICKSTART.md (ativacao rapida)"
        fi
    fi

    # Instala arquivo espec√≠fico da plataforma na raiz do projeto
    case "$platform" in
        "claude-code")
            local template="$templates_dir/CLAUDE.md.tmpl"
            local output="$path/CLAUDE.md"
            if [ -f "$template" ] && should_write_file "$output"; then
                process_template "$template" "$output"
                print_success "Criado: CLAUDE.md (lembrete de ativa√ß√£o)"
            fi
            ;;
        "cursor")
            local template="$templates_dir/cursorrules.tmpl"
            local output="$path/.cursorrules"
            if [ -f "$template" ] && should_write_file "$output"; then
                process_template "$template" "$output"
                print_success "Criado: .cursorrules (lembrete de ativa√ß√£o)"
            fi
            ;;
        "gemini")
            local template="$templates_dir/GEMINI.md.tmpl"
            local output="$path/GEMINI.md"
            if [ -f "$template" ] && should_write_file "$output"; then
                process_template "$template" "$output"
                print_success "Criado: GEMINI.md (lembrete de ativa√ß√£o)"
            fi
            ;;
        "aider")
            local template="$templates_dir/AIDER.md.tmpl"
            local output="$path/AIDER.md"
            if [ -f "$template" ] && should_write_file "$output"; then
                process_template "$template" "$output"
                print_success "Criado: AIDER.md (lembrete de ativa√ß√£o)"
            fi
            ;;
        *)
            # Para plataformas gen√©ricas, cria um arquivo na raiz
            local template="$templates_dir/AI_INSTRUCTIONS.md.tmpl"
            local output="$path/AI_INSTRUCTIONS.md"
            if [ -f "$template" ] && should_write_file "$output"; then
                process_template "$template" "$output"
                print_success "Criado: AI_INSTRUCTIONS.md (lembrete de ativa√ß√£o)"
            fi
            ;;
    esac
}

# Adiciona .aidev/state ao .gitignore do projeto se existir
setup_gitignore() {
    local path="$1"
    local gitignore="$path/.gitignore"
    
    if [ -d "$path/.git" ] || [ -f "$gitignore" ]; then
        if [ ! -f "$gitignore" ]; then
            echo "# AI Dev Superpowers" > "$gitignore"
        fi
        
        if ! grep -q ".aidev/state/" "$gitignore"; then
            echo "" >> "$gitignore"
            echo "# AI Dev State (dynamic session data)" >> "$gitignore"
            echo ".aidev/state/" >> "$gitignore"
            echo ".env" >> "$gitignore"
            print_debug "Adicionado .aidev/state/ e .env ao .gitignore"
        fi
    fi
}

# Configura segredos interativamente
setup_secrets() {
    local path="$1"
    local env_file="$path/.env"
    
    # Carrega env existente se houver
    load_env "$env_file"
    
    # Context7 API Key
    if [ -z "${CONTEXT7_API_KEY:-}" ]; then
        if [ "${AIDEV_INTERACTIVE:-true}" != "true" ]; then
            print_warning "Modo n√£o-interativo: Pulando configuracao de segredos (Context7 API Key)."
            return
        fi

        print_header "Configurac√£o de Segredos"
        print_info "O MCP Context7 requer uma API Key para funcionar."
        print_info "Crie uma em: https://context7.com/dashboard"
        echo -n "üîë Cole sua Context7 API Key (ou Enter para pular): "
        read -r key
        
        if [ -n "$key" ]; then
            set_env_value "CONTEXT7_API_KEY" "$key" "$env_file"
            print_success "Chave configurada com sucesso!"
        else
            print_warning "Chave n√£o configurada. O Context7 pode n√£o funcionar."
        fi
    fi
}

# ============================================================================
# Main
# ============================================================================

# ============================================================================
# Novos Comandos Intuitivos (v3.2)
# ============================================================================

# Subcomando: mcp
# Gerencia servidores MCP
cmd_mcp() {
    local subcommand="${2:-}"
    shift 2 2>/dev/null || true
    
    # N√ÉO chamamos parse_args aqui porque ele falha com flags espec√≠ficas do subcomando (ex: --command)
    # Assumimos path atual se n√£o especificado (limita√ß√£o: --install-in n√£o funciona aqui por enquanto)
    local install_path="."
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")
    
    if ! has_aidev_installed "$install_path"; then
        print_error "AI Dev n√£o est√° instalado neste diret√≥rio"
        exit 1
    fi
    
    # Carrega m√≥dulo MCP
    load_module "mcp"
    
    case "$subcommand" in
        list|"")
            mcp_list_servers "$install_path"
            ;;
        add)
            local name=""
            local command=""
            local args=""
            
            # Parse args manually for this subcommand
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --command) command="$2"; shift 2 ;;
                    --args) args="$2"; shift 2 ;;
                    *) 
                        if [ -z "$name" ]; then 
                            name="$1"
                            shift
                        else
                            # Ignora outros argumentos desconhecidos para evitar erro
                            shift 
                        fi 
                        ;;
                esac
            done
            
            mcp_add_server "$name" "$command" "$args" "$install_path"
            ;;
        remove|rm)
            local name="$1"
            mcp_remove_server "$name" "$install_path"
            ;;
        *)
            print_error "Subcomando desconhecido: $subcommand"
            echo "Uso: aidev mcp [list|add|remove]"
            exit 1
            ;;
    esac
}

# Subcomando: new-feature
# Inicia fluxo completo de nova feature: brainstorming -> planning -> TDD
cmd_new_feature() {
    local description="${2:-}"
    shift 2 2>/dev/null || true
    parse_args "$@"

    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")

    if ! has_aidev_installed "$install_path"; then
        print_error "AI Dev nao esta instalado neste diretorio"
        print_info "Execute 'aidev init' primeiro"
        exit 1
    fi

    if [ -z "$description" ]; then
        print_error "Descricao da feature e obrigatoria"
        echo "Uso: aidev new-feature \"descricao da feature\""
        exit 1
    fi

    # Carrega modulo de estado unificado
    load_module "state" 2>/dev/null || source "$AIDEV_LIB_DIR/state.sh"
    load_module "orchestration" 2>/dev/null || source "$AIDEV_LIB_DIR/orchestration.sh"

    local project_name=$(detect_project_name "$install_path")
    local stack=$(detect_stack "$install_path")

    print_header "$(_ "cmd_new_feature_title")"
    echo ""
    print_info "Projeto: $project_name"
    print_info "Stack: $stack"
    print_info "Feature: $description"
    echo ""

    # Inicializa estado unificado
    export CLI_INSTALL_PATH="$install_path"
    state_init

    # Classifica intent e configura fluxo
    local intent="feature_request"
    local agents=$(orchestrator_select_agents "$intent")
    local skill=$(orchestrator_select_skill "$intent")

    # Cria checkpoint antes de iniciar
    state_checkpoint "Inicio de nova feature: $description"

    # Registra confianca inicial
    state_log_confidence "Iniciar feature: $description" "0.7" "medium"

    # Configura fluxo de skills
    state_write "active_intent" "$intent"
    state_write "intent_description" "$description"
    state_activate_skill "$skill"

    print_section "Fluxo Configurado"
    echo "  Intent:  $intent"
    echo "  Skill:   $skill"
    echo "  Agentes: $agents"
    echo ""

    print_section "Proximos Passos"
    echo "  1. Ative o modo agente na sua IA (Claude Code, Cursor, etc.)"
    echo "  2. Diga: 'modo agente' ou 'aidev'"
    echo "  3. O orquestrador ira conduzir o fluxo:"
    echo ""
    echo "     brainstorming -> writing-plans -> test-driven-development"
    echo "           |              |                    |"
    echo "     Architect        Architect          Backend/Frontend"
    echo ""
    
    # Gera prompt de ativacao
    print_section "Prompt de Ativacao (copie e cole na IA)"
    echo "----------------------------------------"
    cat << EOF
MODO AGENTE - Nova Feature

Contexto:
- Projeto: $project_name
- Stack: $stack
- Intent: $intent
- Skill inicial: $skill

Feature solicitada:
"$description"

Instrucoes:
1. Leia o arquivo .aidev/agents/orchestrator.md
2. Inicie a skill '$skill'
3. Siga o fluxo: brainstorming -> writing-plans -> test-driven-development
4. Use TDD obrigatorio: RED -> GREEN -> REFACTOR

Confirme que entendeu e inicie o brainstorming fazendo perguntas clarificadoras.
EOF
    echo "----------------------------------------"
    echo ""

    print_success "Fluxo de nova feature configurado!"
    print_info "Estado salvo em: .aidev/state/unified.json"
}

# Subcomando: fix-bug
# Inicia fluxo de correcao de bug: systematic-debugging -> learned-lesson
cmd_fix_bug() {
    local description="${2:-}"
    shift 2 2>/dev/null || true
    parse_args "$@"

    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")

    if ! has_aidev_installed "$install_path"; then
        print_error "AI Dev nao esta instalado neste diretorio"
        print_info "Execute 'aidev init' primeiro"
        exit 1
    fi

    if [ -z "$description" ]; then
        print_error "Descricao do bug e obrigatoria"
        echo "Uso: aidev fix-bug \"descricao do bug\""
        exit 1
    fi

    # Carrega modulos
    load_module "state" 2>/dev/null || source "$AIDEV_LIB_DIR/state.sh"
    load_module "orchestration" 2>/dev/null || source "$AIDEV_LIB_DIR/orchestration.sh"

    local project_name=$(detect_project_name "$install_path")
    local stack=$(detect_stack "$install_path")

    print_header "$(_ "cmd_fix_bug_title")"
    echo ""
    print_info "Projeto: $project_name"
    print_info "Stack: $stack"
    print_info "Bug: $description"
    echo ""

    # Inicializa estado
    export CLI_INSTALL_PATH="$install_path"
    state_init

    # Classifica intent
    local intent="bug_fix"
    local agents=$(orchestrator_select_agents "$intent")
    local skill=$(orchestrator_select_skill "$intent")

    # Cria checkpoint
    state_checkpoint "Inicio de fix bug: $description"

    # Registra confianca
    state_log_confidence "Fix bug: $description" "0.6" "medium"

    # Configura fluxo
    state_write "active_intent" "$intent"
    state_write "intent_description" "$description"
    state_activate_skill "$skill"

    print_section "Fluxo Configurado"
    echo "  Intent:  $intent"
    echo "  Skill:   $skill"
    echo "  Agentes: $agents"
    echo ""

    print_section "Metodologia de Debug"
    echo "  Phase 1: REPRODUCE - Criar teste que falha"
    echo "  Phase 2: ISOLATE   - Binary search para isolar causa"
    echo "  Phase 3: ROOT CAUSE - 5 Whys para encontrar raiz"
    echo "  Phase 4: FIX       - Corrigir e prevenir"
    echo ""

    print_section "Prompt de Ativacao (copie e cole na IA)"
    echo "----------------------------------------"
    cat << EOF
MODO AGENTE - Fix Bug

Contexto:
- Projeto: $project_name
- Stack: $stack
- Intent: $intent
- Skill: $skill

Bug reportado:
"$description"

Instrucoes:
1. Leia o arquivo .aidev/agents/orchestrator.md
2. Inicie a skill '$skill'
3. Siga as 4 fases do debugging sistematico:
   - REPRODUCE: Crie um teste que reproduza o bug
   - ISOLATE: Use binary search para isolar
   - ROOT CAUSE: Aplique 5 Whys
   - FIX: Corrija e crie teste de regressao
4. Ao final, registre a licao aprendida

Confirme que entendeu e comece pela fase REPRODUCE.
EOF
    echo "----------------------------------------"
    echo ""

    print_success "Fluxo de fix bug configurado!"
    print_info "Estado salvo em: .aidev/state/unified.json"
}

# Subcomando: suggest
# Analisa projeto e sugere proximo passo baseado em contexto
cmd_suggest() {
    parse_args "$@"

    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")

    if ! has_aidev_installed "$install_path"; then
        print_error "AI Dev nao esta instalado neste diretorio"
        print_info "Execute 'aidev init' primeiro"
        exit 1
    fi

    # Carrega modulos
    load_module "state" 2>/dev/null || source "$AIDEV_LIB_DIR/state.sh"
    load_module "orchestration" 2>/dev/null || source "$AIDEV_LIB_DIR/orchestration.sh"

    local project_name=$(detect_project_name "$install_path")
    local stack=$(detect_stack "$install_path")
    local maturity=$(detect_maturity "$install_path")

    print_header "$(_ "cmd_suggest_title")"
    echo ""

    # Inicializa estado
    export CLI_INSTALL_PATH="$install_path"
    state_init

    # Coleta informacoes do projeto
    local active_skill=$(state_get_active_skill)
    local active_agent=$(state_get_active_agent)
    local has_tests=false
    local has_failing_tests=false
    local has_uncommitted=false
    local has_prd=false

    # Verifica testes
    if [ -f "$install_path/package.json" ] || [ -f "$install_path/composer.json" ] || [ -f "$install_path/pytest.ini" ]; then
        has_tests=true
    fi

    # Verifica mudancas nao commitadas
    if [ -d "$install_path/.git" ]; then
        if [ -n "$(git -C "$install_path" status --porcelain 2>/dev/null)" ]; then
            has_uncommitted=true
        fi
    fi

    # Verifica PRD
    if [ -f "$install_path/docs/PRD.md" ] || [ -f "$install_path/PRD.md" ]; then
        has_prd=true
    fi

    print_section "Analise do Projeto"
    echo "  Projeto:     $project_name"
    echo "  Stack:       $stack"
    echo "  Maturidade:  $maturity"
    echo "  PRD:         $([ "$has_prd" = true ] && echo "Sim" || echo "Nao")"
    echo "  Testes:      $([ "$has_tests" = true ] && echo "Configurados" || echo "Nao detectados")"
    echo "  Git Status:  $([ "$has_uncommitted" = true ] && echo "Mudancas pendentes" || echo "Limpo")"
    echo ""

    # Estado atual
    print_section "Estado Atual"
    if [ -n "$active_skill" ] && [ "$active_skill" != "null" ]; then
        local progress=$(skill_get_progress "$active_skill" 2>/dev/null || echo "0/0")
        echo "  Skill Ativa: $active_skill ($progress)"
    else
        echo "  Skill Ativa: Nenhuma"
    fi
    
    if [ -n "$active_agent" ] && [ "$active_agent" != "null" ]; then
        echo "  Agente Ativo: $active_agent"
    else
        echo "  Agente Ativo: Nenhum"
    fi
    echo ""

    # Gera sugestoes
    print_section "Sugestoes"
    
    local suggestion_count=0

    # Sugestao 1: Skill pendente
    if [ -n "$active_skill" ] && [ "$active_skill" != "null" ]; then
        ((suggestion_count++)) || true
        echo "  $suggestion_count. Continuar skill '$active_skill' em andamento"
        echo "     Comando: Ative o modo agente e diga 'continuar $active_skill'"
        echo ""
    fi

    # Sugestao 2: Mudancas nao commitadas
    if [ "$has_uncommitted" = true ]; then
        ((suggestion_count++)) || true
        echo "  $suggestion_count. Commitar mudancas pendentes"
        echo "     Comando: git add . && git commit -m \"...\""
        echo ""
    fi

    # Sugestao 3: Brownfield sem testes
    if [ "$maturity" = "brownfield" ] && [ "$has_tests" = false ]; then
        ((suggestion_count++)) || true
        echo "  $suggestion_count. Adicionar testes ao projeto legado"
        echo "     Comando: aidev new-feature \"Adicionar suite de testes\""
        echo ""
    fi

    # Sugestao 4: Greenfield sem PRD
    if [ "$maturity" = "greenfield" ] && [ "$has_prd" = false ]; then
        ((suggestion_count++)) || true
        echo "  $suggestion_count. Criar documento de requisitos (PRD)"
        echo "     Acao: Crie docs/PRD.md com requisitos do projeto"
        echo ""
    fi

    # Sugestao 5: Brownfield - analisar legado
    if [ "$maturity" = "brownfield" ]; then
        ((suggestion_count++)) || true
        echo "  $suggestion_count. Rodar analise de codigo legado"
        echo "     Comando: Ative modo agente e diga 'analisar codigo legado'"
        echo ""
    fi

    # Sugestao padrao
    if [ $suggestion_count -eq 0 ]; then
        echo "  Projeto parece estar em bom estado!"
        echo ""
        echo "  Comandos disponiveis:"
        echo "    aidev new-feature \"descricao\"  - Iniciar nova feature"
        echo "    aidev fix-bug \"descricao\"      - Corrigir um bug"
        echo "    aidev status                    - Ver status detalhado"
        echo ""
    fi

    # Licoes recentes (KB)
    local kb_dir="$install_path/.aidev/memory/kb"
    if [ -d "$kb_dir" ] && [ "$(ls -A "$kb_dir" 2>/dev/null)" ]; then
        local count=$(ls "$kb_dir"/*.md 2>/dev/null | wc -l)
        print_section "Base de Conhecimento (KB)"
        echo "  üìö $count licoes disponiveis."
        echo "     Use 'aidev lessons' para consultar."
        echo ""
    fi

    print_success "Analise concluida!"
}

# Subcomando: refactor
# Inicia fluxo de refatoracao
cmd_refactor() {
    local description="${2:-}"
    shift 2 2>/dev/null || true
    parse_args "$@"

    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")

    if ! has_aidev_installed "$install_path"; then
        print_error "AI Dev nao esta instalado neste diretorio"
        print_info "Execute 'aidev init' primeiro"
        exit 1
    fi

    if [ -z "$description" ]; then
        print_error "Escopo da refatoracao e obrigatorio"
        echo "Uso: aidev refactor \"escopo da refatoracao\""
        exit 1
    fi

    # Carrega modulos
    load_module "state" 2>/dev/null || source "$AIDEV_LIB_DIR/state.sh"
    load_module "orchestration" 2>/dev/null || source "$AIDEV_LIB_DIR/orchestration.sh"

    local project_name=$(detect_project_name "$install_path")
    local stack=$(detect_stack "$install_path")

    print_header "AI Dev Superpowers - Refatoracao"
    echo ""
    print_info "Projeto: $project_name"
    print_info "Stack: $stack"
    print_info "Escopo: $description"
    echo ""

    # Inicializa estado
    export CLI_INSTALL_PATH="$install_path"
    state_init

    # Classifica intent
    local intent="refactor"
    local agents=$(orchestrator_select_agents "$intent")
    local skill=$(orchestrator_select_skill "$intent")

    # Cria checkpoint
    state_checkpoint "Inicio de refatoracao: $description"

    # Configura fluxo
    state_write "active_intent" "$intent"
    state_write "intent_description" "$description"
    state_activate_skill "$skill"

    print_section "Fluxo Configurado"
    echo "  Intent:  $intent"
    echo "  Skill:   $skill"
    echo "  Agentes: $agents"
    echo ""

    print_section "Prompt de Ativacao (copie e cole na IA)"
    echo "----------------------------------------"
    cat << EOF
MODO AGENTE - Refatoracao

Contexto:
- Projeto: $project_name
- Stack: $stack
- Intent: $intent
- Skill: $skill

Escopo da refatoracao:
"$description"

Instrucoes:
1. Leia o arquivo .aidev/agents/orchestrator.md
2. Execute legacy-analyzer primeiro para mapear impacto
3. Inicie a skill '$skill' para criar plano
4. Siga TDD: garanta que testes existem antes de refatorar
5. Mantenha comportamento externo identico

Confirme que entendeu e comece pela analise de impacto.
EOF
    echo "----------------------------------------"
    echo ""

    print_success "Fluxo de refatoracao configurado!"
}

# Subcomando: config
# Gerencia configuracoes do AI Dev
cmd_config() {
    local subcommand="${2:-}"
    
    # Shift manual para passar argumentos corretamente
    shift 2 2>/dev/null || true
    
    case "$subcommand" in
        language|lang)
            cmd_config_language "$@"
            ;;
        *)
            print_error "Subcomando desconhecido: $subcommand"
            echo "Uso: aidev config [language]"
            exit 1
            ;;
    esac
}

# Subcomando: lessons
# Gerencia e consulta base de conhecimento (KB)
cmd_lessons() {
    local action="${2:-list}"
    local query="${3:-}"
    
    # Suporte a flags
    local search_mode=false
    local read_mode=false
    local query_term=""
    
    # Parse simples de argumentos
    local args=("$@")
    for ((i=1; i<${#args[@]}+1; i++)); do
        local arg="${args[$i]}"
        case "$arg" in
            --search|-s)
                search_mode=true
                query_term="${args[$((i+1))]}"
                ((i++))
                ;;
            --read|-r)
                read_mode=true
                query_term="${args[$((i+1))]}"
                ((i++))
                ;;
        esac
    done

    # Se usou argumento posicional sem flag
    if [ "$search_mode" = false ] && [ "$read_mode" = false ]; then
        if [ "$action" = "search" ]; then
            search_mode=true
            query_term="$query"
        elif [ "$action" = "read" ]; then
            read_mode=true
            query_term="$query"
        fi
    fi

    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")
    local kb_dir="$install_path/.aidev/memory/kb"

    if ! has_aidev_installed "$install_path"; then
        print_error "AI Dev nao esta instalado neste diretorio"
        exit 1
    fi

    print_header "AI Dev Knowledge Base (KB)"
    
    if [ ! -d "$kb_dir" ]; then
        print_warning "Diretorio de conhecimento nao encontrado: .aidev/memory/kb/"
        ensure_dir "$kb_dir"
        print_success "Diretorio criado."
    fi

    # Modo Leitura
    if [ "$read_mode" = true ]; then
        if [ -z "$query_term" ]; then
            print_error "Especifique o nome ou ID do arquivo para ler."
            exit 1
        fi
        
        # Tenta achar arquivo exato ou parcial
        local target_file=""
        if [ -f "$kb_dir/$query_term" ]; then
            target_file="$kb_dir/$query_term"
        elif [ -f "$kb_dir/$query_term.md" ]; then
            target_file="$kb_dir/$query_term.md"
        else
            # Busca por padrao
            target_file=$(ls "$kb_dir"/*"$query_term"* 2>/dev/null | head -n 1)
        fi
        
        if [ -n "$target_file" ] && [ -f "$target_file" ]; then
            print_section "Licao: $(basename "$target_file")"
            echo ""
            cat "$target_file"
            echo ""
        else
            print_error "Licao nao encontrada: $query_term"
        fi
        return
    fi

    # Modo Busca/Listagem
    local count=0
    local files=()
    
    # Coleta arquivos
    if [ "$search_mode" = true ]; then
        print_info "Buscando por: '$query_term'"
        # Busca no nome ou conteudo
        if [ -n "$query_term" ]; then
            files=($(grep -l "$query_term" "$kb_dir"/*.md 2>/dev/null))
        fi
    else
        # Lista todos, mais recentes primeiro
        files=($(ls -t "$kb_dir"/*.md 2>/dev/null))
    fi

    echo ""
    if [ ${#files[@]} -gt 0 ]; then
        print_section "Licoes Encontradas (${#files[@]})"
        for file in "${files[@]}"; do
            local filename=$(basename "$file")
            local title=$(head -n 1 "$file" | sed 's/^# //')
            if [ -z "$title" ]; then title="(Sem titulo)"; fi
            
            echo "  üìÑ $filename"
            echo "     ‚îî‚îÄ $title"
            ((count++)) || true
        done
        
        echo ""
        print_info "Para ler uma licao: aidev lessons --read <nome-arquivo>"
    else
        if [ "$search_mode" = true ]; then
            print_warning "Nenhuma licao encontrada para '$query_term'."
        else
            print_info "Nenhuma licao registrada ainda."
            echo "Dica: Use a skill 'learned-lesson' apos corrigir um bug."
        fi
    fi
    echo ""
}

# Subcomando: config language
cmd_config_language() {
    local lang="${1:-}"
    
    if [ -z "$lang" ]; then
        print_error "Idioma obrigatorio. Uso: aidev config language [en|pt]"
        exit 1
    fi
    
    if [[ "$lang" != "en" && "$lang" != "pt" && "$lang" != "pt-BR" ]]; then
        print_error "Idioma invalido: $lang. Use 'en' ou 'pt'."
        exit 1
    fi
    
    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")
    local env_file="$install_path/.env"
    
    if [ ! -f "$env_file" ]; then
        print_error ".env nao encontrado em $install_path"
        exit 1
    fi
    
    # Atualiza .env
    set_env_value "AIDEV_LANG" "$lang" "$env_file"
    
    # Atualiza variavel atual para feedback imediato
    export AIDEV_LANG="$lang"
    set_language "$lang" 2>/dev/null || true
    
    # Re-instala agentes e regras para aplicar novo idioma
    print_step "Atualizando agentes e regras para $lang..."
    
    # Necessario carregar envVars de install_path para install_agents funcionar (CLI_PLATFORM etc)
    # Mas CLI_PLATFORM √© global. Se nao estiver setado, tentamos detectar.
    if [ -z "${CLI_PLATFORM:-}" ]; then
         CLI_PLATFORM=$(detect_platform 2>/dev/null || echo "antigravity")
    fi
    if [ -z "${CLI_STACK:-}" ]; then
         CLI_STACK=$(detect_stack "$install_path" 2>/dev/null || echo "generic")
    fi
    
    install_agents "$install_path"
    install_rules "$install_path" "$CLI_STACK"
    
    print_success "$(_ "config_lang_updated" "Idioma atualizado para: ") $lang"
}

# Subcomando: release
# Gerencia ciclo de release e versionamento
cmd_release() {
    # O primeiro argumento ($1) √© 'release'.
    # O segundo ($2) pode ser o tipo de bump (major, minor, patch).
    local bump_type="patch"
    
    # Verifica se o segundo argumento √© um tipo de bump conhecido
    if [[ "$2" == "major" || "$2" == "minor" || "$2" == "patch" || "$2" == "current" ]]; then
        bump_type="$2"
        shift 2 # Consome 'release' e o tipo
    else
        shift 1 # Consome apenas 'release'
    fi

    parse_args "$@"
    
    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")
    
    if ! has_aidev_installed "$install_path"; then
        print_error "AI Dev nao esta instalado neste diretorio"
        print_info "Execute 'aidev init' primeiro"
        exit 1
    fi
    
    # Carrega m√≥dulos necess√°rios
    load_module "state" 2>/dev/null || source "$AIDEV_LIB_DIR/state.sh"
    load_module "orchestration" 2>/dev/null || source "$AIDEV_LIB_DIR/orchestration.sh"
    
    local project_name=$(detect_project_name "$install_path")
    local stack=$(detect_stack "$install_path")
    local intent="release"
    local skill="release-management"
    
    print_header "AI Dev - Release Manager"
    echo ""
    
    # Define Agentes baseados no intent (Orquestrador j√° sabe lidar com isso)
    local agents=$(orchestrator_select_agents "$intent")
    
    # Configura fluxo no estado
    export CLI_INSTALL_PATH="$install_path"
    state_init
    state_write "active_intent" "$intent"
    state_write "intent_description" "Prepare release ($bump_type) version bump"
    state_activate_skill "$skill"
    
    print_section "Fluxo Configurado"
    echo "  Intent:  $intent"
    echo "  Tipo:    $bump_type"
    echo "  Skill:   $skill"
    echo "  Agentes: $agents"
    echo ""
    
    print_section "Prompt de Ativacao (copie e cole na IA)"
    echo "----------------------------------------"
    cat << EOF
MODO AGENTE - Release Manager

Contexto:
- Projeto: $project_name
- Stack: $stack
- Intent: $intent
- Tipo de Bump: $bump_type

Instrucoes:
1. Leia o arquivo .aidev/agents/orchestrator.md
2. Ative o agente 'release-manager' e a skill '$skill'
3. Execute o checklist de release:
   - Identifique arquivos de versao
   - Verifique integridade (testes, git status)
   - Atualize versoes e changelog
   - Gere comamndos de git tag

Confirme que entendeu e inicie a Verificacao de Integridade (Pre-check).
EOF
    echo "----------------------------------------"
    echo ""
    
    print_success "Modo Release Manager configurado!"
}

# Subcomando: self-upgrade
# Atualiza a instalacao global do aidev CLI
cmd_self_upgrade() {
    shift || true
    parse_args "$@"

    print_header "AI Dev - Self Upgrade"

    # Detecta diretorio de instalacao global
    local global_install=""
    local source_dir=""

    # Verifica symlink do aidev
    local aidev_path
    aidev_path=$(which aidev 2>/dev/null || echo "")

    if [ -z "$aidev_path" ]; then
        print_error "aidev nao encontrado no PATH"
        exit 1
    fi

    # Resolve symlink
    if [ -L "$aidev_path" ]; then
        local real_path
        real_path=$(readlink -f "$aidev_path")
        global_install=$(dirname "$(dirname "$real_path")")
    else
        global_install=$(dirname "$(dirname "$aidev_path")")
    fi

    print_info "Instalacao global: $global_install"

    # Versao atual
    local current_version
    current_version=$(grep "AIDEV_VERSION" "$global_install/lib/core.sh" 2>/dev/null | grep -oP '\d+\.\d+\.\d+' | head -1 || echo "desconhecida")
    print_info "Versao atual: $current_version"

    # Detecta source (projeto atual ou diretorio padrao)
    if [ -f "./lib/core.sh" ]; then
         source_dir=$(pwd)
    elif [ -f "$AIDEV_ROOT_DIR/lib/core.sh" ] && [ "$AIDEV_ROOT_DIR" != "$global_install" ]; then
         source_dir="$AIDEV_ROOT_DIR"
    elif [ -d "$HOME/projects/aidev-superpowers-v3" ]; then
         source_dir="$HOME/projects/aidev-superpowers-v3"
    elif [ -d "$HOME/aidev-superpowers" ]; then
         source_dir="$HOME/aidev-superpowers"
    fi

    if [ -z "$source_dir" ] || [ ! -d "$source_dir" ]; then
        print_error "Diretorio source nao encontrado"
        print_info "Opcoes:"
        echo "  1. Clone o repositorio: git clone https://github.com/nandinhos/aidev-superpowers-v3.git"
        echo "  2. Execute de dentro do diretorio do projeto"
        exit 1
    fi

    # Versao do source
    local source_version
    source_version=$(grep "AIDEV_VERSION" "$source_dir/lib/core.sh" 2>/dev/null | grep -oP '\d+\.\d+\.\d+' | head -1 || echo "desconhecida")
    print_info "Versao no source: $source_version"
    print_info "Source: $source_dir"
    echo ""

    # Verifica se precisa atualizar
    if [ "$current_version" = "$source_version" ] && [ "$AIDEV_FORCE" != true ]; then
        print_success "Ja esta na versao mais recente ($current_version)"
        exit 0
    fi

    print_step "Atualizando $current_version -> $source_version"
    echo ""

    # Dry run check
    if [ "$AIDEV_DRY_RUN" = true ]; then
        print_info "[DRY-RUN] Arquivos que seriam atualizados:"
        echo "  - bin/aidev"
        echo "  - lib/*.sh"
        echo "  - templates/"
        exit 0
    fi

    # Executa sync
    print_step "Sincronizando bin/..."
    rsync -a --delete "$source_dir/bin/" "$global_install/bin/" 2>/dev/null || {
        print_error "Falha ao sincronizar bin/"
        exit 1
    }

    print_step "Sincronizando lib/..."
    rsync -a --delete "$source_dir/lib/" "$global_install/lib/" 2>/dev/null || {
        print_error "Falha ao sincronizar lib/"
        exit 1
    }

    print_step "Sincronizando templates/..."
    rsync -a --delete "$source_dir/templates/" "$global_install/templates/" 2>/dev/null || {
        print_error "Falha ao sincronizar templates/"
        exit 1
    }

    # Sincroniza tests se existir
    if [ -d "$source_dir/tests" ]; then
        print_step "Sincronizando tests/..."
        rsync -a --delete "$source_dir/tests/" "$global_install/tests/" 2>/dev/null || true
    fi

    echo ""
    print_success "Atualizado com sucesso: $current_version -> $source_version"

    # Verifica a nova versao
    local new_version
    new_version=$("$global_install/bin/aidev" --version 2>/dev/null | grep -oP '\d+\.\d+\.\d+' || echo "")
    if [ -n "$new_version" ]; then
        print_info "Verificado: aidev v$new_version"
    fi
}

main() {
    local command="${1:-help}"
    # shift || true # Deixa o comando original para o parse_args identificar
    
    case "$command" in
        init)
            cmd_init "$@"
            ;;
        config)
            cmd_config "$@"
            ;;
        mcp)
            cmd_mcp "$@"
            ;;
        upgrade)
            cmd_upgrade "$@"
            ;;
        add-skill)
            cmd_add_skill "$@"
            ;;
        add-rule)
            cmd_add_rule "$@"
            ;;
        add-agent)
            cmd_add_agent "$@"
            ;;
        status)
            cmd_status "$@"
            ;;
        doctor)
            cmd_doctor "$@"
            ;;
        snapshot)
            cmd_snapshot "$@"
            ;;
        agent)
            cmd_agent "$@"
            ;;
        cache)
            cmd_cache "$@"
            ;;
        start)
            cmd_start "$@"
            ;;
        metrics)
            cmd_metrics "$@"
            ;;
        integrity)
            cmd_doctor "$@"
            ;;
        new-feature)
            cmd_new_feature "$@"
            ;;
        fix-bug)
            cmd_fix_bug "$@"
            ;;
        suggest)
            cmd_suggest "$@"
            ;;
        lessons)
            cmd_lessons "$@"
            ;;
        refactor)
            cmd_refactor "$@"
            ;;
        release)
            cmd_release "$@"
            ;;
        self-upgrade)
            cmd_self_upgrade "$@"
            ;;
        -h|--help|help)
            show_help
            ;;
        -v|--version|version)
            show_version
            ;;
        *)
            print_error "Comando desconhecido: $command"
            echo ""
            echo "Use 'aidev --help' para ver comandos dispon√≠veis"
            exit 1
            ;;
    esac
}

# Executa
main "$@"
