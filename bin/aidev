#!/bin/bash

# ============================================================================
# AI Dev Superpowers V3 - CLI Principal
# ============================================================================
# Comando unificado 'aidev' para gest√£o de projetos com AI
# 
# Uso: aidev <comando> [op√ß√µes]
# ============================================================================

set -eEo pipefail

# Handler de erro para Auto-Cura (Fase 4)
error_handler() {
    local exit_code=$?
    local line_no=$1
    
    # Ignora erros se j√° estivermos dentro do doctor para evitar loop infinito
    if [[ "${BASH_COMMAND:-}" == *"doctor"* ]]; then
        return
    fi

    echo ""
    echo "‚ùå $(_ "error_ops") (Erro: $exit_code na linha $line_no)"
    echo "üîç $(_ "suggest_doctor")"
    echo ""
}

trap 'error_handler $LINENO' ERR

# Detecta diret√≥rio do script (resolve symlinks)
SOURCE="${BASH_SOURCE[0]}"
while [ -L "$SOURCE" ]; do
    DIR="$(cd -P "$(dirname "$SOURCE")" && pwd)"
    SOURCE="$(readlink "$SOURCE")"
    [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
done
AIDEV_BIN_DIR="$(cd -P "$(dirname "$SOURCE")" && pwd)"
AIDEV_ROOT_DIR="$(dirname "$AIDEV_BIN_DIR")"
AIDEV_LIB_DIR="$AIDEV_ROOT_DIR/lib"

# Carrega m√≥dulos essenciais
source "$AIDEV_LIB_DIR/loader.sh"
load_essential_modules
load_module "templates"
load_module "mcp"

# ============================================================================
# Subcomandos
# ============================================================================

# Subcomando: init
# Inicializa AI Dev em um projeto
cmd_init() {
    parse_args "$@"
    
    if ! validate_args; then
        exit 1
    fi
    # Diret√≥rio de instala√ß√£o
    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")

    # Sele√ß√£o de Idioma Interativa
    if [ "${AIDEV_INTERACTIVE:-true}" = "true" ] && [ -z "${CLI_LANGUAGE:-}" ]; then
        echo -n "$(_ "select_lang")"
        read -r selected_lang
        case "$selected_lang" in
            en|EN) CLI_LANGUAGE="en" ;;
            pt|PT|pt-BR|PT-BR) CLI_LANGUAGE="pt-BR" ;;
            *) CLI_LANGUAGE="pt-BR" ;; # Default
        esac
    fi
    set_language "${CLI_LANGUAGE:-pt-BR}"

    print_header "AI Dev Superpowers"
    print_mode "$CLI_MODE" "$(_ "init_header") $install_path"
    
    # Auto-detec√ß√£o de stack
    if [ "$CLI_AUTO_DETECT" = "true" ]; then
        CLI_STACK=$(detect_stack "$install_path")
        print_info "Stack detectada: $CLI_STACK"
    fi
    
    # Auto-detec√ß√£o de plataforma
    if [ "$CLI_PLATFORM" = "auto" ]; then
        CLI_PLATFORM=$(detect_platform)
        print_info "Plataforma detectada: $CLI_PLATFORM"
    fi
    
    # Mostra configura√ß√£o
    if [ "${AIDEV_DEBUG:-false}" = "true" ]; then
        show_config_summary
    fi
    
    # Dry run apenas mostra o que seria feito
    if [ "$AIDEV_DRY_RUN" = "true" ]; then
        print_info "[DRY-RUN] Simulando instala√ß√£o..."
    fi
    
    # Reseta contadores
    reset_counters
    
    # Cria estrutura base
    print_step "$(_ "step_structure")"
    create_base_structure "$install_path"
    
    # Instala agentes
    print_step "$(_ "step_agents")"
    install_agents "$install_path"
    
    # Instala skills
    print_step "$(_ "step_skills")"
    install_skills "$install_path"
    
    # Instala rules
    print_step "$(_ "step_rules")"
    install_rules "$install_path" "$CLI_STACK"
    
    # Configura segredos PRIMEIRO (antes do MCP para ter API Keys dispon√≠veis)
    if [ "$CLI_NO_MCP" != "true" ]; then
        print_step "$(_ "step_secrets")"
        setup_secrets "$install_path"

        # Carrega as vari√°veis do .env para usar na configura√ß√£o MCP
        load_env "$install_path/.env"
    fi

    # Configura MCP (agora com API Keys j√° definidas)
    if [ "$CLI_NO_MCP" != "true" ]; then
        print_step "$(_ "step_mcp")"
        configure_mcp "$install_path" "$CLI_PLATFORM"
    fi

    # Instala instru√ß√µes de ativa√ß√£o para a plataforma
    print_step "$(_ "step_platform")"
    install_platform_instructions "$install_path" "$CLI_PLATFORM"

    # Configura gitignore
    print_step "$(_ "step_gitignore")"
    setup_gitignore "$install_path"

    # Persiste estado inicial
    export CLI_INSTALL_PATH="$install_path"
    set_state_value "current_fase" "3"
    set_state_value "current_sprint" "4"
    set_state_value "current_platform" "$CLI_PLATFORM"
    set_state_value "current_stack" "$CLI_STACK"
    set_state_value "language" "$CLI_LANGUAGE"
    set_state_value "initialized_at" "$(date -Iseconds)"

    # Sum√°rio final
    print_summary "$CLI_MODE" "$CLI_STACK"
    
    print_success "$(_ "init_success")"
}

# Subcomando: upgrade
# Atualiza instala√ß√£o existente
cmd_upgrade() {
    parse_args "$@"

    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")

    if ! has_aidev_installed "$install_path"; then
        print_error "AI Dev n√£o est√° instalado neste diret√≥rio"
        print_info "Use 'aidev init' para instalar"
        exit 1
    fi

    print_header "AI Dev Superpowers"
    print_mode "upgrade" "Atualizando em $install_path"

    # Detecta stack e plataforma
    CLI_STACK=$(detect_stack "$install_path")
    local platform="${CLI_PLATFORM:-auto}"
    if [ "$platform" = "auto" ]; then
        platform=$(detect_platform)
    fi
    print_info "Stack: $CLI_STACK | Plataforma: $platform"

    # Backup antes de atualizar
    print_step "Criando backup..."
    local backup_dir="$install_path/.aidev/backups/$(date +%Y%m%d%H%M%S)"
    ensure_dir "$backup_dir"
    cp -r "$install_path/.aidev/agents" "$backup_dir/" 2>/dev/null || true
    cp -r "$install_path/.aidev/skills" "$backup_dir/" 2>/dev/null || true

    reset_counters
    AIDEV_FORCE=true

    # Garante estrutura base (novos diret√≥rios)
    create_base_structure "$install_path"

    # Reinstala componentes
    print_step "Atualizando agentes..."
    install_agents "$install_path"

    print_step "Atualizando skills..."
    install_skills "$install_path"

    # Atualiza instru√ß√µes de plataforma
    print_step "Atualizando instru√ß√µes de plataforma..."
    install_platform_instructions "$install_path" "$platform"

    print_summary "upgrade" "$CLI_STACK"
    print_success "Atualiza√ß√£o conclu√≠da!"
    print_info "Backup salvo em: $backup_dir"
}

# Subcomando: add-skill
# Adiciona skill customizada
cmd_add_skill() {
    local skill_name="${1:-}"
    shift || true
    parse_args "$@"
    
    if [ -z "$skill_name" ]; then
        print_error "Nome da skill √© obrigat√≥rio"
        echo "Uso: aidev add-skill <nome>"
        exit 1
    fi
    
    local install_path="${CLI_INSTALL_PATH:-.}"
    local skill_dir="$install_path/.aidev/skills/$skill_name"
    
    if [ -d "$skill_dir" ] && [ "$AIDEV_FORCE" != "true" ]; then
        print_warning "Skill '$skill_name' j√° existe (use --force)"
        exit 1
    fi
    
    print_step "Criando skill '$skill_name'..."
    
    ensure_dir "$skill_dir"
    
    # Cria SKILL.md template
    cat > "$skill_dir/SKILL.md" << EOF
---
name: $skill_name
description: Descri√ß√£o da skill $skill_name
triggers:
  - "trigger1"
  - "trigger2"
globs:
  - "**/*.md"
---

# $skill_name Skill

## When to Use
[Descreva quando usar esta skill]

## Purpose
[Descreva o prop√≥sito]

## Process
1. [Passo 1]
2. [Passo 2]
3. [Passo 3]

## Key Principles
- [Princ√≠pio 1]
- [Princ√≠pio 2]
EOF
    
    print_success "Skill '$skill_name' criada em $skill_dir"
    print_info "Edite o arquivo SKILL.md para customizar"
}

# Subcomando: add-rule
# Adiciona regra customizada
cmd_add_rule() {
    local rule_name="${1:-}"
    shift || true
    parse_args "$@"
    
    if [ -z "$rule_name" ]; then
        print_error "Nome da rule √© obrigat√≥rio"
        echo "Uso: aidev add-rule <nome>"
        exit 1
    fi
    
    local install_path="${CLI_INSTALL_PATH:-.}"
    local rule_file="$install_path/.aidev/rules/${rule_name}.md"
    
    if [ -f "$rule_file" ] && [ "$AIDEV_FORCE" != "true" ]; then
        print_warning "Rule '$rule_name' j√° existe (use --force)"
        exit 1
    fi
    
    print_step "Criando rule '$rule_name'..."
    
    ensure_dir "$(dirname "$rule_file")"
    
    cat > "$rule_file" << EOF
# $rule_name Rules

## Conventions
[Descreva as conven√ß√µes]

## Patterns
[Descreva os patterns a seguir]

## Anti-Patterns
[Descreva o que evitar]

## Examples
\`\`\`
// Exemplo de c√≥digo
\`\`\`
EOF
    
    print_success "Rule '$rule_name' criada: $rule_file"
}

# Subcomando: add-agent
# Adiciona agente customizado
cmd_add_agent() {
    local agent_name="${1:-}"
    shift || true
    parse_args "$@"
    
    if [ -z "$agent_name" ]; then
        print_error "Nome do agente √© obrigat√≥rio"
        echo "Uso: aidev add-agent <nome>"
        exit 1
    fi
    
    local install_path="${CLI_INSTALL_PATH:-.}"
    local agent_file="$install_path/.aidev/agents/${agent_name}.md"
    
    if [ -f "$agent_file" ] && [ "$AIDEV_FORCE" != "true" ]; then
        print_warning "Agent '$agent_name' j√° existe (use --force)"
        exit 1
    fi
    
    print_step "Criando agent '$agent_name'..."
    
    ensure_dir "$(dirname "$agent_file")"
    
    cat > "$agent_file" << EOF
# $agent_name Agent

## Role
[Descreva o papel deste agente]

## Responsibilities
- [Responsabilidade 1]
- [Responsabilidade 2]
- [Responsabilidade 3]

## Guidelines
- [Guideline 1]
- [Guideline 2]

## Tools
- [Tool 1]
- [Tool 2]
EOF
    
    print_success "Agent '$agent_name' criado: $agent_file"
}

# Subcomando: status
# Mostra status da instala√ß√£o
cmd_status() {
    parse_args "$@"
    
    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")
    
    print_header "AI Dev Superpowers"
    
    if ! has_aidev_installed "$install_path"; then
        print_warning "AI Dev n√£o est√° instalado neste diret√≥rio"
        exit 0
    fi
    
    print_success "AI Dev instalado: $install_path/.aidev/"
    
    # Detecta contexto
    local stack=$(detect_stack "$install_path")
    local platform=$(detect_platform)
    local project_name=$(detect_project_name "$install_path")
    
    print_section "Contexto"
    echo "  Projeto:    $project_name"
    echo "  Stack:      $stack"
    echo "  Plataforma: $platform"
    
    # Progresso da Sess√£o (usa vari√°veis globais sincronizadas em sync_session_state)
    # Exibe dashboard
    print_section "Progresso"
    echo "  Fase:       ${current_fase:-1}"
    echo "  Sprint:     ${current_sprint:-0}"
    echo "  Tarefa:     ${current_task:-Pendente}"
    echo "  √öltima Ativ: ${initialized_at:-N/A}"
    
    # Hist√≥rico Git Recente
    if [ -d "$install_path/.git" ]; then
        print_section "Hist√≥rico Recente (Git)"
        git -C "$install_path" log -n 3 --oneline | sed 's/^/  /'
    fi
    
    # Lista agentes
    print_section "Agentes Instalados"
    local agents_dir="$install_path/.aidev/agents"
    if [ -d "$agents_dir" ]; then
        local count=0
        for agent in "$agents_dir"/*.md; do
            if [ -f "$agent" ]; then
                echo "  ‚Ä¢ $(basename "$agent" .md)"
                ((count++)) || true
            fi
        done
        echo "  Total: $count agentes"
    else
        echo "  Nenhum agente instalado"
    fi
    
    # Lista skills
    print_section "Skills Instaladas"
    local skills_dir="$install_path/.aidev/skills"
    if [ -d "$skills_dir" ]; then
        local count=0
        for skill in "$skills_dir"/*/SKILL.md; do
            if [ -f "$skill" ]; then
                local skill_name=$(dirname "$skill")
                echo "  ‚Ä¢ $(basename "$skill_name")"
                ((count++)) || true
            fi
        done
        echo "  Total: $count skills"
    else
        echo "  Nenhuma skill instalada"
    fi
    
    # Lista rules
    print_section "Rules Instaladas"
    local rules_dir="$install_path/.aidev/rules"
    if [ -d "$rules_dir" ]; then
        local count=0
        for rule in "$rules_dir"/*.md; do
            if [ -f "$rule" ]; then
                echo "  ‚Ä¢ $(basename "$rule" .md)"
                ((count++)) || true
            fi
        done
        echo "  Total: $count rules"
    else
        echo "  Nenhuma rule instalada"
    fi
    
    echo ""
}

# Subcomando: snapshot
# Gera um resumo do contexto atual para migra√ß√£o entre IAs
cmd_snapshot() {
    parse_args "$@"
    
    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")
    
    if ! has_aidev_installed "$install_path"; then
        print_error "AI Dev n√£o est√° instalado neste diret√≥rio"
        exit 1
    fi

    print_header "AI Dev Snapshot (Context Passport)"
    print_info "Gerando resumo t√©cnico para migra√ß√£o de modelo..."
    echo ""

    # Coleta dados
    local fase=$(get_state_value "current_fase" "1")
    local sprint=$(get_state_value "current_sprint" "0")
    local task=$(get_state_value "current_task" "Pendente")
    local project_name=$(detect_project_name "$install_path")
    local stack=$(detect_stack "$install_path")
    local platform=$(detect_platform)

    # In√≠cio do bloco de snapshot
    echo "--- SNAPSHOT START ---"
    echo "Crie um novo chat de IA e cole o conte√∫do abaixo:"
    echo "------------------------------------------------"
    echo ""
    echo "# üõ∞Ô∏è AI DEV CONTEXT SNAPSHOT: $project_name"
    echo ""
    echo "## üìç Estado Operacional"
    echo "- **Fase**: $fase"
    echo "- **Sprint**: $sprint"
    echo "- **Tarefa Atual**: $task"
    echo "- **Stack**: $stack"
    echo "- **Origem**: $platform"
    echo ""

    echo "## üìú Hist√≥rico Recente (Git)"
    if [ -d "$install_path/.git" ]; then
        git log -n 5 --oneline | sed 's/^/- /'
    else
        echo "- (Git n√£o dispon√≠vel ou n√£o inicializado)"
    fi
    echo ""

    echo "## üìã Decis√µes e Planos Ativos"
    local plans=""
    [ -f "$install_path/implementation_plan.md" ] && plans="$plans- ./implementation_plan.md\n"
    [ -d "$install_path/docs/plans" ] && plans="$plans$(ls "$install_path/docs/plans"/*.md 2>/dev/null | sed "s|$install_path/||" | sed 's/^/- /')\n"
    
    if [ -n "$plans" ]; then
        echo -e "$plans"
    else
        echo "- Nenhum plano de implementa√ß√£o detectado."
    fi
    echo ""

    echo "## üß† Li√ß√µes Aprendidas Recentes"
    local lessons_dir="$install_path/.aidev/state/lessons"
    if [ -d "$lessons_dir" ]; then
        ls -F "$lessons_dir" 2>/dev/null | grep -v "/" | head -n 5 | sed 's/^/- /' || echo "- Nenhuma li√ß√£o registrada nesta sess√£o."
    else
        echo "- Nenhuma li√ß√£o registrada nesta sess√£o."
    fi
    echo ""

    echo "## üöÄ Instru√ß√µes para o Pr√≥ximo Modelo"
    echo "1. Leia o arquivo \`task.md\` e \`implementation_plan.md\` se existirem."
    echo "2. O projeto usa o framework AI Dev Superpowers V3."
    echo "3. Continue a partir da tarefa: **$task**."
    echo ""
    echo "------------------------------------------------"
    echo "--- SNAPSHOT END ---"
    echo ""

    print_success "Snapshot gerado com sucesso! Copie o bloco acima."
}

# Subcomando: agent
# Gera prompt de ativacao do modo agente para colar na IA
cmd_agent() {
    parse_args "$@"

    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")

    if ! has_aidev_installed "$install_path"; then
        print_error "AI Dev nao esta instalado neste diretorio"
        print_info "Execute 'aidev init' primeiro"
        exit 1
    fi

    # Coleta dados do projeto
    local project_name=$(detect_project_name "$install_path")
    local stack=$(detect_stack "$install_path")
    local platform=$(detect_platform)
    local fase=$(get_state_value "current_fase" "1")
    local sprint=$(get_state_value "current_sprint" "0")

    # Conta agentes e skills
    local agent_count=0
    local skill_count=0
    if [ -d "$install_path/.aidev/agents" ]; then
        agent_count=$(ls "$install_path/.aidev/agents"/*.md 2>/dev/null | wc -l)
    fi
    if [ -d "$install_path/.aidev/skills" ]; then
        skill_count=$(ls -d "$install_path/.aidev/skills"/*/ 2>/dev/null | wc -l)
    fi

    print_header "AI Dev Agent Mode"
    print_info "Gerando prompt de ativacao..."
    echo ""

    # Gera o prompt
    echo "============================================================"
    echo "COPIE E COLE O TEXTO ABAIXO NA SUA IA:"
    echo "============================================================"
    echo ""
    cat << EOF
ATIVAR MODO AGENTE - AI Dev Superpowers

Voce esta em um projeto com AI Dev Superpowers v3 instalado.

PROJETO: $project_name
STACK: $stack
FASE: $fase | SPRINT: $sprint
AGENTES: $agent_count especializados
SKILLS: $skill_count automatizadas

INSTRUCOES DE ATIVACAO:

1. Leia o arquivo .aidev/agents/orchestrator.md - este e seu cerebro de coordenacao
2. Voce tem acesso a $agent_count agentes especializados em .aidev/agents/
3. Voce tem acesso a $skill_count skills automatizadas em .aidev/skills/
4. Siga as regras da stack em .aidev/rules/$stack.md

PRINCIPIOS INEGOCIAVEIS:
- TDD OBRIGATORIO: Sempre escreva teste ANTES do codigo (RED -> GREEN -> REFACTOR)
- YAGNI: So implemente o que foi solicitado
- Commits atomicos com mensagens descritivas

FLUXO DE TRABALHO:
- Para novas features: brainstorming -> writing-plans -> test-driven-development -> code-review
- Para bugs: systematic-debugging -> learned-lesson
- Para refatoracao: writing-plans -> test-driven-development -> code-review

AGENTES DISPONIVEIS:
EOF

    # Lista agentes
    if [ -d "$install_path/.aidev/agents" ]; then
        for agent in "$install_path/.aidev/agents"/*.md; do
            if [ -f "$agent" ]; then
                local name=$(basename "$agent" .md)
                echo "- $name"
            fi
        done
    fi

    cat << EOF

SKILLS DISPONIVEIS:
EOF

    # Lista skills
    if [ -d "$install_path/.aidev/skills" ]; then
        for skill_dir in "$install_path/.aidev/skills"/*/; do
            if [ -d "$skill_dir" ]; then
                local name=$(basename "$skill_dir")
                echo "- $name"
            fi
        done
    fi

    cat << EOF

Confirme que voce entendeu e esta pronto para operar como orquestrador.
Responda: "Modo Agente ativado. Pronto para orquestrar."
EOF

    echo ""
    echo "============================================================"
    echo ""
    print_success "Prompt gerado! Cole na sua IA para ativar o modo agente."
    echo ""
    print_info "Dica: Use 'aidev agent | pbcopy' (macOS) ou 'aidev agent | xclip' (Linux) para copiar automaticamente"
}

# Subcomando: start
# Inicia sessao interativa do modo agente (exibe instrucoes de ativacao)
cmd_start() {
    parse_args "$@"

    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")

    if ! has_aidev_installed "$install_path"; then
        print_error "AI Dev nao esta instalado neste diretorio"
        print_info "Execute 'aidev init' primeiro"
        exit 1
    fi

    local project_name=$(detect_project_name "$install_path")
    local stack=$(detect_stack "$install_path")
    local platform=$(detect_platform)

    print_header "AI Dev Superpowers - Modo Agente"
    echo ""
    print_success "Projeto: $project_name"
    print_info "Stack: $stack | Plataforma: $platform"
    echo ""

    print_section "Como Ativar o Modo Agente"
    echo ""
    echo "  Opcao 1: Diga para sua IA:"
    echo "    ${CYAN}\"modo agente\"${NC} ou ${CYAN}\"aidev\"${NC} ou ${CYAN}\"superpowers\"${NC}"
    echo ""
    echo "  Opcao 2: Gere um prompt completo:"
    echo "    ${CYAN}aidev agent${NC}"
    echo ""
    echo "  Opcao 3: Cole o prompt diretamente:"
    echo "    ${CYAN}aidev agent | pbcopy${NC}  (macOS)"
    echo "    ${CYAN}aidev agent | xclip -selection clipboard${NC}  (Linux)"
    echo ""

    print_section "Agentes Disponiveis"
    if [ -d "$install_path/.aidev/agents" ]; then
        for agent in "$install_path/.aidev/agents"/*.md; do
            if [ -f "$agent" ]; then
                echo "  - $(basename "$agent" .md)"
            fi
        done
    fi
    echo ""

    print_section "Skills Disponiveis"
    if [ -d "$install_path/.aidev/skills" ]; then
        for skill_dir in "$install_path/.aidev/skills"/*/; do
            if [ -d "$skill_dir" ]; then
                echo "  - $(basename "$skill_dir")"
            fi
        done
    fi
    echo ""

    print_section "Proximos Passos"
    echo "  1. Abra sua IA (Claude Code, Cursor, etc.)"
    echo "  2. Diga 'modo agente' ou use 'aidev agent'"
    echo "  3. O orquestrador assumira o controle"
    echo ""
}

# Subcomando: doctor
# Diagn√≥stico da instala√ß√£o e ambiente com sugest√µes de reparo
cmd_doctor() {
    parse_args "$@"
    
    local fix_mode=false
    for arg in "$@"; do
        if [ "$arg" == "--fix" ]; then
            fix_mode=true
        fi
    done

    local install_path="${CLI_INSTALL_PATH:-.}"
    install_path=$(cd "$install_path" 2>/dev/null && pwd || echo "$install_path")
    
    print_header "AI Dev Doctor"
    
    local issues=0
    local warnings=0

    # 1. Depend√™ncias do Sistema (Core)
    print_section "Dependencias do Sistema"
    local deps=("git" "jq" "bash" "sed" "grep")
    for dep in "${deps[@]}"; do
        if command -v "$dep" >/dev/null 2>&1; then
            print_success "$dep: $(command -v "$dep")"
        else
            if [ "$dep" == "jq" ]; then
                print_warning "$dep: NAO ENCONTRADO (usando fallback Bash)"
                ((warnings++)) || true
            else
                print_error "$dep: NAO ENCONTRADO"
                ((issues++)) || true
            fi
        fi
    done

    # 1.1 Depend√™ncias MCP (para servidores MCP funcionarem)
    print_section "Dependencias MCP"

    # Node.js / npx (para Context7)
    if command -v node >/dev/null 2>&1; then
        local node_version=$(node --version 2>/dev/null)
        print_success "node: $node_version"
        if command -v npx >/dev/null 2>&1; then
            print_success "npx: $(command -v npx)"
        else
            print_warning "npx: NAO ENCONTRADO (Context7 MCP nao funcionara)"
            ((warnings++)) || true
        fi
    else
        print_warning "node: NAO ENCONTRADO (Context7 MCP nao funcionara)"
        ((warnings++)) || true
    fi

    # Python / uvx (para Serena e basic-memory)
    if command -v python3 >/dev/null 2>&1; then
        local python_version=$(python3 --version 2>/dev/null)
        print_success "python3: $python_version"
    else
        print_warning "python3: NAO ENCONTRADO"
        ((warnings++)) || true
    fi

    if command -v uvx >/dev/null 2>&1; then
        print_success "uvx: $(command -v uvx)"
    elif command -v uv >/dev/null 2>&1; then
        print_success "uv: $(command -v uv) (uvx disponivel via 'uv tool run')"
    else
        print_warning "uvx/uv: NAO ENCONTRADO (Serena e basic-memory MCP nao funcionarao)"
        print_info "Instale com: curl -LsSf https://astral.sh/uv/install.sh | sh"
        ((warnings++)) || true
    fi
    
    # 2. Verifica instala√ß√£o
    print_section "Verificando Instala√ß√£o"
    if has_aidev_installed "$install_path"; then
        print_success ".aidev/ existe"
        
        # Verifica diret√≥rios
        local dirs=("agents" "skills" "rules" "state" "memory/kb")
        for dir in "${dirs[@]}"; do
            if [ -d "$install_path/.aidev/$dir" ]; then
                print_success ".aidev/$dir/ existe"
            else
                if [ "$fix_mode" = "true" ]; then
                    print_info "$(_ "fix_recreating_dir") .aidev/$dir/"
                    ensure_dir "$install_path/.aidev/$dir"
                    print_success ".aidev/$dir/ $(_ "fix_created")"
                else
                    print_warning ".aidev/$dir/ n√£o encontrado"
                    ((warnings++)) || true
                fi
            fi
        done
    else
        print_error ".aidev/ n√£o encontrado em $install_path"
        if [ "$fix_mode" = "true" ]; then
            print_info "$(_ "fix_restoring_base")"
            create_base_structure "$install_path"
            print_success "$(_ "fix_restored")"
        else
            ((issues++)) || true
        fi
    fi
    
    # 3. Estado da Sess√£o
    print_section "Estado da Sess√£o"
    local state_file="$install_path/.aidev/state/session.json"
    if [ -f "$state_file" ]; then
        if command -v jq >/dev/null 2>&1 && ! jq . "$state_file" >/dev/null 2>&1; then
            print_error "Arquivo session.json corrompido"
            ((issues++)) || true
        else
            print_success "Arquivo session.json √≠ntegro"
        fi
    else
        print_info "session.json ainda n√£o inicializado"
    fi
    
    # 4. Segredos e Seguran√ßa
    print_section "Segredos e Seguranca"
    local env_file="$install_path/.env"
    if [ -f "$env_file" ]; then
        load_env "$env_file"
        if [ -n "${CONTEXT7_API_KEY:-}" ]; then
            print_success "Context7 API Key configurada"
        else
            print_warning "Context7 API Key ausente no .env"
            ((warnings++)) || true
        fi
        
        # Verifica se .env est√° no gitignore
        if [ -f "$install_path/.gitignore" ]; then
            if grep -q "^\.env" "$install_path/.gitignore" || grep -q "/\.env" "$install_path/.gitignore"; then
                print_success ".env protegido no .gitignore"
            else
                if [ "$fix_mode" = "true" ]; then
                    print_info "$(_ "fix_protecting_env")"
                    echo ".env" >> "$install_path/.gitignore"
                    print_success "$(_ "fix_protected_env")"
                else
                    print_error ".env N√ÉO est√° no .gitignore (RISCO DE EXPOSI√á√ÉO)"
                    ((issues++)) || true
                fi
            fi
        fi
    else
        print_info ".env nao encontrado (opcional, mas recomendado para MCP)"
    fi

    # 4.1 Verificacao de sincronizacao MCP
    print_section "Sincronizacao MCP"
    local mcp_file="$install_path/.mcp.json"
    if [ -f "$mcp_file" ]; then
        if command -v jq >/dev/null 2>&1; then
            local mcp_key=$(jq -r '.mcpServers.context7.env.CONTEXT7_API_KEY // empty' "$mcp_file" 2>/dev/null)
            local env_key="${CONTEXT7_API_KEY:-}"

            if [ -n "$env_key" ] && [ -n "$mcp_key" ]; then
                if [ "$env_key" = "$mcp_key" ]; then
                    print_success ".mcp.json sincronizado com .env"
                else
                    print_warning ".mcp.json desatualizado (API Key diferente do .env)"
                    if [ "$fix_mode" = "true" ]; then
                        print_info "Regenerando .mcp.json..."
                        AIDEV_FORCE=true
                        configure_mcp "$install_path" "$(detect_platform)"
                        print_success ".mcp.json atualizado!"
                    else
                        print_info "Execute 'aidev doctor --fix' para sincronizar"
                    fi
                    ((warnings++)) || true
                fi
            elif [ -n "$env_key" ] && [ -z "$mcp_key" ]; then
                print_warning ".mcp.json nao tem API Key configurada"
                if [ "$fix_mode" = "true" ]; then
                    print_info "Regenerando .mcp.json..."
                    AIDEV_FORCE=true
                    configure_mcp "$install_path" "$(detect_platform)"
                    print_success ".mcp.json atualizado!"
                fi
                ((warnings++)) || true
            elif [ -z "$env_key" ]; then
                print_info "API Key nao configurada (Context7 pode nao funcionar)"
            fi
        else
            print_info ".mcp.json existe (jq nao disponivel para validar sincronizacao)"
        fi
    else
        print_info ".mcp.json nao encontrado"
    fi

    # 5. Contexto
    print_section "Contexto Detectado"
    local platform=$(detect_platform)
    local stack=$(detect_stack "$install_path")
    print_info "Plataforma: $platform"
    print_info "Stack:      $stack"

    # 6. Verifica√ß√£o de Integridade Cr√≠tica
    print_section "Integridade do Sistema"
    local critical_dirs=(".aidev/agents" ".aidev/skills" ".aidev/rules" "bin")
    for dir in "${critical_dirs[@]}"; do
        if [ -d "$install_path/$dir" ]; then
            print_success "Diret√≥rio vital ok: $dir"
        else
            print_error "DIRET√ìRIO VITAL AUSENTE: $dir"
            ((issues++)) || true
        fi
    done

    # 5. Sugest√µes de Reparo
    if [ $issues -gt 0 ] || [ $warnings -gt 0 ]; then
        print_section "Sugest√µes de Reparo"
        if ! command -v jq >/dev/null 2>&1; then
            echo -e "  ‚Ä¢ ${YELLOW}Instalar jq:${NC} sudo apt install jq  (ou brew install jq)"
        fi
        if ! command -v git >/dev/null 2>&1; then
            echo -e "  ‚Ä¢ ${RED}Instalar git:${NC} sudo apt install git"
        fi
        if [ ! -d "$install_path/.aidev" ]; then
            echo -e "  ‚Ä¢ ${CYAN}Inicializar Projeto:${NC} aidev init"
        fi
        if [ -f "$install_path/.env" ] && [ -z "${CONTEXT7_API_KEY:-}" ]; then
            echo -e "  ‚Ä¢ ${YELLOW}Context7:${NC} Adicione CONTEXT7_API_KEY ao seu arquivo .env"
        fi
    fi

    echo ""
    if [ $issues -eq 0 ]; then
        if [ $warnings -eq 0 ]; then
            print_success "Tudo limpo! Seu ambiente est√° saud√°vel."
        else
            print_info "Ambiente operacional, mas com $warnings avisos."
        fi
    else
        print_error "Encontrados $issues problemas cr√≠ticos. Verifique as mensagens acima."
    fi
    echo ""
}

# ============================================================================
# Fun√ß√µes de Instala√ß√£o
# ============================================================================

# Cria estrutura base de diret√≥rios
create_base_structure() {
    local path="$1"
    
    ensure_dir "$path/.aidev"
    ensure_dir "$path/.aidev/agents"
    ensure_dir "$path/.aidev/skills"
    ensure_dir "$path/.aidev/rules"
    ensure_dir "$path/.aidev/state"
    ensure_dir "$path/.aidev/state/lessons"
    ensure_dir "$path/.aidev/memory/kb"
    ensure_dir "$path/.aidev/analysis"
}

# Instala agentes a partir dos templates com suporte a overrides por plataforma
install_agents() {
    local path="$1"
    local agents_dir="$path/.aidev/agents"
    local platform_agents_dir="$AIDEV_ROOT_DIR/templates/platform/$CLI_PLATFORM/agents"
    
    # Exporta vari√°veis para os templates
    export PROJECT_NAME=$(detect_project_name "$path")
    export STACK="$CLI_STACK"
    export PLATFORM="$CLI_PLATFORM"
    
    # Itera sobre os templates globais primeiro para garantir que todos os b√°sicos existam
    for template in "$AIDEV_ROOT_DIR/templates/agents"/*.md.tmpl; do
        if [ -f "$template" ]; then
            local name=$(basename "$template" .md.tmpl)
            local output="$agents_dir/${name}.md"
            
            # Verifica se existe override na plataforma
            local template_to_use="$template"
            if [ -n "$CLI_PLATFORM" ] && [ -f "$platform_agents_dir/${name}.md.tmpl" ]; then
                template_to_use="$platform_agents_dir/${name}.md.tmpl"
                print_debug "Usando override de plataforma para: $name"
            fi
            
            if should_write_file "$output"; then
                process_template "$template_to_use" "$output"
                print_debug "Instalado: $name (de $(basename "$(dirname "$template_to_use")"))"
            fi
        fi
    done
}

# Instala skills a partir dos templates
install_skills() {
    local path="$1"
    local skills_dir="$path/.aidev/skills"
    
    for skill_template_dir in "$AIDEV_ROOT_DIR/templates/skills"/*/; do
        if [ -d "$skill_template_dir" ]; then
            local skill_name=$(basename "$skill_template_dir")
            local output_dir="$skills_dir/$skill_name"
            
            ensure_dir "$output_dir"
            
            for template in "$skill_template_dir"/*.tmpl; do
                if [ -f "$template" ]; then
                    local name=$(basename "$template" .tmpl)
                    local output="$output_dir/$name"
                    
                    if should_write_file "$output"; then
                        process_template "$template" "$output"
                    fi
                fi
            done
        fi
    done
}

# Instala rules a partir dos templates
install_rules() {
    local path="$1"
    local stack="$2"
    local rules_dir="$path/.aidev/rules"
    
    # Sempre instala generic
    local generic_template="$AIDEV_ROOT_DIR/templates/rules/generic.md.tmpl"
    if [ -f "$generic_template" ]; then
        process_template "$generic_template" "$rules_dir/generic.md"
    fi
    
    # Instala rule espec√≠fica da stack
    local stack_template="$AIDEV_ROOT_DIR/templates/rules/${stack}.md.tmpl"
    if [ -f "$stack_template" ]; then
        process_template "$stack_template" "$rules_dir/${stack}.md"
    fi
}

# Configura MCP
configure_mcp() {
    local path="$1"
    local platform="$2"

    # Carrega m√≥dulo MCP se n√£o carregado
    load_module "mcp" 2>/dev/null || true

    # Setup completo do MCP Engine
    setup_mcp_engine "$path" "$platform"
}

# Instala instru√ß√µes de plataforma (lembrete de ativa√ß√£o)
install_platform_instructions() {
    local path="$1"
    local platform="$2"

    # Exporta vari√°veis para templates
    export PROJECT_NAME=$(detect_project_name "$path")
    export STACK="$CLI_STACK"

    local templates_dir="$AIDEV_ROOT_DIR/templates/platform"

    # Sempre instala o arquivo gen√©rico AI_INSTRUCTIONS.md em .aidev/
    local generic_template="$templates_dir/AI_INSTRUCTIONS.md.tmpl"
    if [ -f "$generic_template" ]; then
        local output="$path/.aidev/AI_INSTRUCTIONS.md"
        if should_write_file "$output"; then
            process_template "$generic_template" "$output"
            print_debug "Instru√ß√µes gen√©ricas: AI_INSTRUCTIONS.md"
        fi
    fi

    # Sempre instala o QUICKSTART.md consolidado em .aidev/
    local quickstart_template="$templates_dir/QUICKSTART.md.tmpl"
    if [ -f "$quickstart_template" ]; then
        local output="$path/.aidev/QUICKSTART.md"
        if should_write_file "$output"; then
            process_template "$quickstart_template" "$output"
            print_success "Criado: .aidev/QUICKSTART.md (ativacao rapida)"
        fi
    fi

    # Instala arquivo espec√≠fico da plataforma na raiz do projeto
    case "$platform" in
        "claude-code")
            local template="$templates_dir/CLAUDE.md.tmpl"
            local output="$path/CLAUDE.md"
            if [ -f "$template" ] && should_write_file "$output"; then
                process_template "$template" "$output"
                print_success "Criado: CLAUDE.md (lembrete de ativa√ß√£o)"
            fi
            ;;
        "cursor")
            local template="$templates_dir/cursorrules.tmpl"
            local output="$path/.cursorrules"
            if [ -f "$template" ] && should_write_file "$output"; then
                process_template "$template" "$output"
                print_success "Criado: .cursorrules (lembrete de ativa√ß√£o)"
            fi
            ;;
        "gemini")
            local template="$templates_dir/GEMINI.md.tmpl"
            local output="$path/GEMINI.md"
            if [ -f "$template" ] && should_write_file "$output"; then
                process_template "$template" "$output"
                print_success "Criado: GEMINI.md (lembrete de ativa√ß√£o)"
            fi
            ;;
        "aider")
            local template="$templates_dir/AIDER.md.tmpl"
            local output="$path/AIDER.md"
            if [ -f "$template" ] && should_write_file "$output"; then
                process_template "$template" "$output"
                print_success "Criado: AIDER.md (lembrete de ativa√ß√£o)"
            fi
            ;;
        *)
            # Para plataformas gen√©ricas, cria um arquivo na raiz
            local template="$templates_dir/AI_INSTRUCTIONS.md.tmpl"
            local output="$path/AI_INSTRUCTIONS.md"
            if [ -f "$template" ] && should_write_file "$output"; then
                process_template "$template" "$output"
                print_success "Criado: AI_INSTRUCTIONS.md (lembrete de ativa√ß√£o)"
            fi
            ;;
    esac
}

# Adiciona .aidev/state ao .gitignore do projeto se existir
setup_gitignore() {
    local path="$1"
    local gitignore="$path/.gitignore"
    
    if [ -d "$path/.git" ] || [ -f "$gitignore" ]; then
        if [ ! -f "$gitignore" ]; then
            echo "# AI Dev Superpowers" > "$gitignore"
        fi
        
        if ! grep -q ".aidev/state/" "$gitignore"; then
            echo "" >> "$gitignore"
            echo "# AI Dev State (dynamic session data)" >> "$gitignore"
            echo ".aidev/state/" >> "$gitignore"
            echo ".env" >> "$gitignore"
            print_debug "Adicionado .aidev/state/ e .env ao .gitignore"
        fi
    fi
}

# Configura segredos interativamente
setup_secrets() {
    local path="$1"
    local env_file="$path/.env"
    
    # Carrega env existente se houver
    load_env "$env_file"
    
    # Context7 API Key
    if [ -z "${CONTEXT7_API_KEY:-}" ]; then
        print_header "Configurac√£o de Segredos"
        print_info "O MCP Context7 requer uma API Key para funcionar."
        print_info "Crie uma em: https://context7.com/dashboard"
        echo -n "üîë Cole sua Context7 API Key (ou Enter para pular): "
        read -r key
        
        if [ -n "$key" ]; then
            set_env_value "CONTEXT7_API_KEY" "$key" "$env_file"
            print_success "Chave configurada com sucesso!"
        else
            print_warning "Chave n√£o configurada. O Context7 pode n√£o funcionar."
        fi
    fi
}

# ============================================================================
# Main
# ============================================================================

main() {
    local command="${1:-help}"
    # shift || true # Deixa o comando original para o parse_args identificar
    
    case "$command" in
        init)
            cmd_init "$@"
            ;;
        upgrade)
            cmd_upgrade "$@"
            ;;
        add-skill)
            cmd_add_skill "$@"
            ;;
        add-rule)
            cmd_add_rule "$@"
            ;;
        add-agent)
            cmd_add_agent "$@"
            ;;
        status)
            cmd_status "$@"
            ;;
        doctor)
            cmd_doctor "$@"
            ;;
        snapshot)
            cmd_snapshot "$@"
            ;;
        agent)
            cmd_agent "$@"
            ;;
        start)
            cmd_start "$@"
            ;;
        integrity)
            cmd_doctor "$@" # Por enquanto usa doctor como base, mas focado em reparo autom√°tico futuramente
            ;;
        -h|--help|help)
            show_help
            ;;
        -v|--version|version)
            show_version
            ;;
        *)
            print_error "Comando desconhecido: $command"
            echo ""
            echo "Use 'aidev --help' para ver comandos dispon√≠veis"
            exit 1
            ;;
    esac
}

# Executa
main "$@"
